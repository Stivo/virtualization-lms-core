[0m[[0minfo[0m] [0mLoading global plugins from /home/stivo/.sbt/plugins[0m
[0m[[0minfo[0m] [0mLoading project definition from /home/stivo/master/distributed/virt/project[0m
[0m[[0minfo[0m] [0mSet current project to LMS (in build file:/home/stivo/master/distributed/virt/)[0m
[0m[[0minfo[0m] [0mCompiling 67 Scala sources to /home/stivo/master/distributed/virt/target/scala-2.10/classes...[0m
[0m[[33mwarn[0m] [0m/home/stivo/master/distributed/virt/src/common/SplitEffects.scala:122: comparing values of types Unit and Unit using `==' will always yield true[0m
[0m[[33mwarn[0m] [0m      case (Block(x), Block(Def(Reify(Const(()), u, es)))) => Block(Reify(x, u, es))[0m
[0m[[33mwarn[0m] [0m                                            ^[0m
[0m[[33mwarn[0m] [0m/home/stivo/master/distributed/virt/src/common/SplitEffects.scala:128: comparing values of types Unit and Unit using `==' will always yield true[0m
[0m[[33mwarn[0m] [0m      case (Block(x), Block(Def(Reify(Const(()), u, es)))) => Block(Reify(x, u, es))[0m
[0m[[33mwarn[0m] [0m                                            ^[0m
exception when typing $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
  {
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
    };
    (new anonymous class $anonfun($anonfun.this): Function1)
  }
}, immutable.this.List.canBuildFrom()))
reassignment to val in file /home/stivo/master/distributed/virt/src/common/SplitEffects.scala
[0m[[31merror[0m] [0munrecoverable error[0m
exception when typing {
  val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
  val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
  $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
  val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
    case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
    case12(){
      if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
        {
          val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
          if (x3.ne(null))
            if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
              {
                val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                if (x7.ne(null))
                  if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                    {
                      val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                      if (x10.ne(null))
                        matchEnd11(x3.sym())
                      else
                        case13()
                    }
                  else
                    case13()
                else
                  case13()
              }
            else
              case13()
          else
            case13()
        }
      else
        case13()
    };
    case13(){
      matchEnd11(throw new MatchError(x1))
    };
    matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
      x
    }
  };
  def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
    case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
    case10(){
      if (x1.ne(null))
        {
          val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
          if (o12.isEmpty().unary_!())
            if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
              {
                val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                if (x7.ne(null))
                  if (x7.effects().isInstanceOf[List]())
                    {
                      val x8: List = (x7.effects().asInstanceOf[List](): List);
                      matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                          def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                            $anonfun.super.<init>();
                            ()
                          };
                          final override def applyOrElse(x$1: Option, default: Function1): Object = {
                            case <synthetic> val x1: Option = x$1;
                            case11(){
                              if (x1.isInstanceOf[Some]())
                                {
                                  val x2: Some = (x1.asInstanceOf[Some](): Some);
                                  if (x2.ne(null))
                                    if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                      {
                                        val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                        if (x4.ne(null))
                                          if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                            {
                                              val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                              if (x7.ne(null))
                                                if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                  {
                                                    val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                    if (x9.ne(null))
                                                      if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                        matchEnd10(x4)
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              else
                                                case12()
                                            }
                                          else
                                            case12()
                                        else
                                          case12()
                                      }
                                    else
                                      case12()
                                  else
                                    case12()
                                }
                              else
                                case12()
                            };
                            case12(){
                              matchEnd10(default.apply(x$1))
                            };
                            matchEnd10(x: Object){
                              x
                            }
                          };
                          final def isDefinedAt(x$1: Option): Boolean = {
                            case <synthetic> val x1: Option = x$1;
                            case11(){
                              if (x1.isInstanceOf[Some]())
                                {
                                  val x2: Some = (x1.asInstanceOf[Some](): Some);
                                  if (x2.ne(null))
                                    if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                      {
                                        val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                        if (x4.ne(null))
                                          if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                            {
                                              val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                              if (x7.ne(null))
                                                if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                  {
                                                    val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                    if (x9.ne(null))
                                                      if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                        matchEnd10(true)
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              else
                                                case12()
                                            }
                                          else
                                            case12()
                                        else
                                          case12()
                                      }
                                    else
                                      case12()
                                  else
                                    case12()
                                }
                              else
                                case12()
                            };
                            case12(){
                              matchEnd10(false)
                            };
                            matchEnd10(x: Boolean){
                              x
                            }
                          };
                          <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                          final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                          final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                        };
                        new anonymous class $anonfun($anonfun.this)
                      }, immutable.this.List.canBuildFrom()))
                    }
                  else
                    case11()
                else
                  case11()
              }
            else
              case11()
          else
            case11()
        }
      else
        case11()
    };
    case11(){
      matchEnd9(throw new MatchError(x1))
    };
    matchEnd9(x: List){
      x
    }
  };
  val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
  val pvss: List = pvs.map({
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
    };
    (new anonymous class $anonfun($anonfun.this): Function1)
  }, immutable.this.List.canBuildFrom());
  def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
    case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
    case8(){
      if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
        {
          val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
          if (x3.ne(null))
            if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
              {
                val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                if (x5.ne(null))
                  if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                    {
                      val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                      if (x6.ne(null))
                        if (pvss.contains(x3.sym()))
                          matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                        else
                          case9()
                      else
                        case9()
                    }
                  else
                    case9()
                else
                  case9()
              }
            else
              case9()
          else
            case9()
        }
      else
        case9()
    };
    case9(){
      matchEnd7(x1)
    };
    matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
      x
    }
  };
  $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
    {
      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
        def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
        <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
      };
      (new anonymous class $anonfun($anonfun.this): Function1)
    }
  }, immutable.this.List.canBuildFrom()));
  $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
    {
      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
        def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
        <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
      };
      (new anonymous class $anonfun($anonfun.this): Function1)
    }
  }, immutable.this.List.canBuildFrom()))
}
exception when typing final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
  val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
  val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
  $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
  val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
    case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
    case12(){
      if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
        {
          val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
          if (x3.ne(null))
            if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
              {
                val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                if (x7.ne(null))
                  if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                    {
                      val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                      if (x10.ne(null))
                        matchEnd11(x3.sym())
                      else
                        case13()
                    }
                  else
                    case13()
                else
                  case13()
              }
            else
              case13()
          else
            case13()
        }
      else
        case13()
    };
    case13(){
      matchEnd11(throw new MatchError(x1))
    };
    matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
      x
    }
  };
  def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
    case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
    case10(){
      if (x1.ne(null))
        {
          val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
          if (o12.isEmpty().unary_!())
            if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
              {
                val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                if (x7.ne(null))
                  if (x7.effects().isInstanceOf[List]())
                    {
                      val x8: List = (x7.effects().asInstanceOf[List](): List);
                      matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                          def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                            $anonfun.super.<init>();
                            ()
                          };
                          final override def applyOrElse(x$1: Option, default: Function1): Object = {
                            case <synthetic> val x1: Option = x$1;
                            case11(){
                              if (x1.isInstanceOf[Some]())
                                {
                                  val x2: Some = (x1.asInstanceOf[Some](): Some);
                                  if (x2.ne(null))
                                    if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                      {
                                        val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                        if (x4.ne(null))
                                          if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                            {
                                              val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                              if (x7.ne(null))
                                                if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                  {
                                                    val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                    if (x9.ne(null))
                                                      if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                        matchEnd10(x4)
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              else
                                                case12()
                                            }
                                          else
                                            case12()
                                        else
                                          case12()
                                      }
                                    else
                                      case12()
                                  else
                                    case12()
                                }
                              else
                                case12()
                            };
                            case12(){
                              matchEnd10(default.apply(x$1))
                            };
                            matchEnd10(x: Object){
                              x
                            }
                          };
                          final def isDefinedAt(x$1: Option): Boolean = {
                            case <synthetic> val x1: Option = x$1;
                            case11(){
                              if (x1.isInstanceOf[Some]())
                                {
                                  val x2: Some = (x1.asInstanceOf[Some](): Some);
                                  if (x2.ne(null))
                                    if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                      {
                                        val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                        if (x4.ne(null))
                                          if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                            {
                                              val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                              if (x7.ne(null))
                                                if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                  {
                                                    val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                    if (x9.ne(null))
                                                      if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                        matchEnd10(true)
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              else
                                                case12()
                                            }
                                          else
                                            case12()
                                        else
                                          case12()
                                      }
                                    else
                                      case12()
                                  else
                                    case12()
                                }
                              else
                                case12()
                            };
                            case12(){
                              matchEnd10(false)
                            };
                            matchEnd10(x: Boolean){
                              x
                            }
                          };
                          <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                          final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                          final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                        };
                        new anonymous class $anonfun($anonfun.this)
                      }, immutable.this.List.canBuildFrom()))
                    }
                  else
                    case11()
                else
                  case11()
              }
            else
              case11()
          else
            case11()
        }
      else
        case11()
    };
    case11(){
      matchEnd9(throw new MatchError(x1))
    };
    matchEnd9(x: List){
      x
    }
  };
  val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
  val pvss: List = pvs.map({
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
    };
    (new anonymous class $anonfun($anonfun.this): Function1)
  }, immutable.this.List.canBuildFrom());
  def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
    case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
    case8(){
      if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
        {
          val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
          if (x3.ne(null))
            if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
              {
                val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                if (x5.ne(null))
                  if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                    {
                      val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                      if (x6.ne(null))
                        if (pvss.contains(x3.sym()))
                          matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                        else
                          case9()
                      else
                        case9()
                    }
                  else
                    case9()
                else
                  case9()
              }
            else
              case9()
          else
            case9()
        }
      else
        case9()
    };
    case9(){
      matchEnd7(x1)
    };
    matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
      x
    }
  };
  $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
    {
      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
        def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
        <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
      };
      (new anonymous class $anonfun($anonfun.this): Function1)
    }
  }, immutable.this.List.canBuildFrom()));
  $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
    {
      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
        def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
        <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
      };
      (new anonymous class $anonfun($anonfun.this): Function1)
    }
  }, immutable.this.List.canBuildFrom()))
}
exception when typing @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
    $anonfun.super.<init>();
    ()
  };
  final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
    val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
    val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
    $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
    val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
      case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
      case12(){
        if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
          {
            val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
            if (x3.ne(null))
              if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                {
                  val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                  if (x7.ne(null))
                    if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                      {
                        val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                        if (x10.ne(null))
                          matchEnd11(x3.sym())
                        else
                          case13()
                      }
                    else
                      case13()
                  else
                    case13()
                }
              else
                case13()
            else
              case13()
          }
        else
          case13()
      };
      case13(){
        matchEnd11(throw new MatchError(x1))
      };
      matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
        x
      }
    };
    def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
      case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
      case10(){
        if (x1.ne(null))
          {
            val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
            if (o12.isEmpty().unary_!())
              if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                {
                  val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                  if (x7.ne(null))
                    if (x7.effects().isInstanceOf[List]())
                      {
                        val x8: List = (x7.effects().asInstanceOf[List](): List);
                        matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                            def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                              $anonfun.super.<init>();
                              ()
                            };
                            final override def applyOrElse(x$1: Option, default: Function1): Object = {
                              case <synthetic> val x1: Option = x$1;
                              case11(){
                                if (x1.isInstanceOf[Some]())
                                  {
                                    val x2: Some = (x1.asInstanceOf[Some](): Some);
                                    if (x2.ne(null))
                                      if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                        {
                                          val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                          if (x4.ne(null))
                                            if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                              {
                                                val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                if (x7.ne(null))
                                                  if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                    {
                                                      val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                      if (x9.ne(null))
                                                        if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                          matchEnd10(x4)
                                                        else
                                                          case12()
                                                      else
                                                        case12()
                                                    }
                                                  else
                                                    case12()
                                                else
                                                  case12()
                                              }
                                            else
                                              case12()
                                          else
                                            case12()
                                        }
                                      else
                                        case12()
                                    else
                                      case12()
                                  }
                                else
                                  case12()
                              };
                              case12(){
                                matchEnd10(default.apply(x$1))
                              };
                              matchEnd10(x: Object){
                                x
                              }
                            };
                            final def isDefinedAt(x$1: Option): Boolean = {
                              case <synthetic> val x1: Option = x$1;
                              case11(){
                                if (x1.isInstanceOf[Some]())
                                  {
                                    val x2: Some = (x1.asInstanceOf[Some](): Some);
                                    if (x2.ne(null))
                                      if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                        {
                                          val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                          if (x4.ne(null))
                                            if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                              {
                                                val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                if (x7.ne(null))
                                                  if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                    {
                                                      val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                      if (x9.ne(null))
                                                        if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                          matchEnd10(true)
                                                        else
                                                          case12()
                                                      else
                                                        case12()
                                                    }
                                                  else
                                                    case12()
                                                else
                                                  case12()
                                              }
                                            else
                                              case12()
                                          else
                                            case12()
                                        }
                                      else
                                        case12()
                                    else
                                      case12()
                                  }
                                else
                                  case12()
                              };
                              case12(){
                                matchEnd10(false)
                              };
                              matchEnd10(x: Boolean){
                                x
                              }
                            };
                            <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                            final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                            final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                          };
                          new anonymous class $anonfun($anonfun.this)
                        }, immutable.this.List.canBuildFrom()))
                      }
                    else
                      case11()
                  else
                    case11()
                }
              else
                case11()
            else
              case11()
          }
        else
          case11()
      };
      case11(){
        matchEnd9(throw new MatchError(x1))
      };
      matchEnd9(x: List){
        x
      }
    };
    val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
    val pvss: List = pvs.map({
      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
        def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
        <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
      };
      (new anonymous class $anonfun($anonfun.this): Function1)
    }, immutable.this.List.canBuildFrom());
    def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
      case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
      case8(){
        if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
          {
            val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
            if (x3.ne(null))
              if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                {
                  val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                  if (x5.ne(null))
                    if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                      {
                        val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                        if (x6.ne(null))
                          if (pvss.contains(x3.sym()))
                            matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                          else
                            case9()
                        else
                          case9()
                      }
                    else
                      case9()
                  else
                    case9()
                }
              else
                case9()
            else
              case9()
          }
        else
          case9()
      };
      case9(){
        matchEnd7(x1)
      };
      matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
        x
      }
    };
    $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
      {
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
          def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
          <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
          final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
        };
        (new anonymous class $anonfun($anonfun.this): Function1)
      }
    }, immutable.this.List.canBuildFrom()));
    $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
      {
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
          def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
          <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
          final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
        };
        (new anonymous class $anonfun($anonfun.this): Function1)
      }
    }, immutable.this.List.canBuildFrom()))
  };
  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
  final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
}
exception when typing {
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
      val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
      val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
      $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
      val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
        case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
        case12(){
          if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
            {
              val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
              if (x3.ne(null))
                if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                  {
                    val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                    if (x7.ne(null))
                      if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                        {
                          val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                          if (x10.ne(null))
                            matchEnd11(x3.sym())
                          else
                            case13()
                        }
                      else
                        case13()
                    else
                      case13()
                  }
                else
                  case13()
              else
                case13()
            }
          else
            case13()
        };
        case13(){
          matchEnd11(throw new MatchError(x1))
        };
        matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
          x
        }
      };
      def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
        case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
        case10(){
          if (x1.ne(null))
            {
              val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
              if (o12.isEmpty().unary_!())
                if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                  {
                    val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                    if (x7.ne(null))
                      if (x7.effects().isInstanceOf[List]())
                        {
                          val x8: List = (x7.effects().asInstanceOf[List](): List);
                          matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                              def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                $anonfun.super.<init>();
                                ()
                              };
                              final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                case <synthetic> val x1: Option = x$1;
                                case11(){
                                  if (x1.isInstanceOf[Some]())
                                    {
                                      val x2: Some = (x1.asInstanceOf[Some](): Some);
                                      if (x2.ne(null))
                                        if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                          {
                                            val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                            if (x4.ne(null))
                                              if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                {
                                                  val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                  if (x7.ne(null))
                                                    if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                      {
                                                        val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                        if (x9.ne(null))
                                                          if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                            matchEnd10(x4)
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  else
                                                    case12()
                                                }
                                              else
                                                case12()
                                            else
                                              case12()
                                          }
                                        else
                                          case12()
                                      else
                                        case12()
                                    }
                                  else
                                    case12()
                                };
                                case12(){
                                  matchEnd10(default.apply(x$1))
                                };
                                matchEnd10(x: Object){
                                  x
                                }
                              };
                              final def isDefinedAt(x$1: Option): Boolean = {
                                case <synthetic> val x1: Option = x$1;
                                case11(){
                                  if (x1.isInstanceOf[Some]())
                                    {
                                      val x2: Some = (x1.asInstanceOf[Some](): Some);
                                      if (x2.ne(null))
                                        if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                          {
                                            val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                            if (x4.ne(null))
                                              if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                {
                                                  val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                  if (x7.ne(null))
                                                    if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                      {
                                                        val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                        if (x9.ne(null))
                                                          if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                            matchEnd10(true)
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  else
                                                    case12()
                                                }
                                              else
                                                case12()
                                            else
                                              case12()
                                          }
                                        else
                                          case12()
                                      else
                                        case12()
                                    }
                                  else
                                    case12()
                                };
                                case12(){
                                  matchEnd10(false)
                                };
                                matchEnd10(x: Boolean){
                                  x
                                }
                              };
                              <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                              final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                              final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                            };
                            new anonymous class $anonfun($anonfun.this)
                          }, immutable.this.List.canBuildFrom()))
                        }
                      else
                        case11()
                    else
                      case11()
                  }
                else
                  case11()
              else
                case11()
            }
          else
            case11()
        };
        case11(){
          matchEnd9(throw new MatchError(x1))
        };
        matchEnd9(x: List){
          x
        }
      };
      val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
      val pvss: List = pvs.map({
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
          def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
          <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
          final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
        };
        (new anonymous class $anonfun($anonfun.this): Function1)
      }, immutable.this.List.canBuildFrom());
      def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
        case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
        case8(){
          if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
            {
              val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
              if (x3.ne(null))
                if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                  {
                    val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                    if (x5.ne(null))
                      if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                        {
                          val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                          if (x6.ne(null))
                            if (pvss.contains(x3.sym()))
                              matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                            else
                              case9()
                          else
                            case9()
                        }
                      else
                        case9()
                    else
                      case9()
                  }
                else
                  case9()
              else
                case9()
            }
          else
            case9()
        };
        case9(){
          matchEnd7(x1)
        };
        matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
          x
        }
      };
      $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
        {
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
            def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
            <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
          };
          (new anonymous class $anonfun($anonfun.this): Function1)
        }
      }, immutable.this.List.canBuildFrom()));
      $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
        {
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
            def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
            <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
          };
          (new anonymous class $anonfun($anonfun.this): Function1)
        }
      }, immutable.this.List.canBuildFrom()))
    };
    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
    final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
}
exception when typing affected.foreach({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
      val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
      val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
      $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
      val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
        case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
        case12(){
          if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
            {
              val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
              if (x3.ne(null))
                if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                  {
                    val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                    if (x7.ne(null))
                      if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                        {
                          val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                          if (x10.ne(null))
                            matchEnd11(x3.sym())
                          else
                            case13()
                        }
                      else
                        case13()
                    else
                      case13()
                  }
                else
                  case13()
              else
                case13()
            }
          else
            case13()
        };
        case13(){
          matchEnd11(throw new MatchError(x1))
        };
        matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
          x
        }
      };
      def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
        case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
        case10(){
          if (x1.ne(null))
            {
              val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
              if (o12.isEmpty().unary_!())
                if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                  {
                    val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                    if (x7.ne(null))
                      if (x7.effects().isInstanceOf[List]())
                        {
                          val x8: List = (x7.effects().asInstanceOf[List](): List);
                          matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                              def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                $anonfun.super.<init>();
                                ()
                              };
                              final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                case <synthetic> val x1: Option = x$1;
                                case11(){
                                  if (x1.isInstanceOf[Some]())
                                    {
                                      val x2: Some = (x1.asInstanceOf[Some](): Some);
                                      if (x2.ne(null))
                                        if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                          {
                                            val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                            if (x4.ne(null))
                                              if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                {
                                                  val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                  if (x7.ne(null))
                                                    if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                      {
                                                        val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                        if (x9.ne(null))
                                                          if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                            matchEnd10(x4)
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  else
                                                    case12()
                                                }
                                              else
                                                case12()
                                            else
                                              case12()
                                          }
                                        else
                                          case12()
                                      else
                                        case12()
                                    }
                                  else
                                    case12()
                                };
                                case12(){
                                  matchEnd10(default.apply(x$1))
                                };
                                matchEnd10(x: Object){
                                  x
                                }
                              };
                              final def isDefinedAt(x$1: Option): Boolean = {
                                case <synthetic> val x1: Option = x$1;
                                case11(){
                                  if (x1.isInstanceOf[Some]())
                                    {
                                      val x2: Some = (x1.asInstanceOf[Some](): Some);
                                      if (x2.ne(null))
                                        if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                          {
                                            val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                            if (x4.ne(null))
                                              if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                {
                                                  val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                  if (x7.ne(null))
                                                    if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                      {
                                                        val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                        if (x9.ne(null))
                                                          if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                            matchEnd10(true)
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  else
                                                    case12()
                                                }
                                              else
                                                case12()
                                            else
                                              case12()
                                          }
                                        else
                                          case12()
                                      else
                                        case12()
                                    }
                                  else
                                    case12()
                                };
                                case12(){
                                  matchEnd10(false)
                                };
                                matchEnd10(x: Boolean){
                                  x
                                }
                              };
                              <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                              final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                              final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                            };
                            new anonymous class $anonfun($anonfun.this)
                          }, immutable.this.List.canBuildFrom()))
                        }
                      else
                        case11()
                    else
                      case11()
                  }
                else
                  case11()
              else
                case11()
            }
          else
            case11()
        };
        case11(){
          matchEnd9(throw new MatchError(x1))
        };
        matchEnd9(x: List){
          x
        }
      };
      val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
      val pvss: List = pvs.map({
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
          def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
          <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
          final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
        };
        (new anonymous class $anonfun($anonfun.this): Function1)
      }, immutable.this.List.canBuildFrom());
      def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
        case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
        case8(){
          if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
            {
              val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
              if (x3.ne(null))
                if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                  {
                    val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                    if (x5.ne(null))
                      if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                        {
                          val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                          if (x6.ne(null))
                            if (pvss.contains(x3.sym()))
                              matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                            else
                              case9()
                          else
                            case9()
                        }
                      else
                        case9()
                    else
                      case9()
                  }
                else
                  case9()
              else
                case9()
            }
          else
            case9()
        };
        case9(){
          matchEnd7(x1)
        };
        matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
          x
        }
      };
      $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
        {
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
            def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
            <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
          };
          (new anonymous class $anonfun($anonfun.this): Function1)
        }
      }, immutable.this.List.canBuildFrom()));
      $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
        {
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
            def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
            <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
          };
          (new anonymous class $anonfun($anonfun.this): Function1)
        }
      }, immutable.this.List.canBuildFrom()))
    };
    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
    final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
})
exception when typing {
  val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
  affected.foreach({
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
        val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
        val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
        $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
        val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
          case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
          case12(){
            if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
              {
                val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                if (x3.ne(null))
                  if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                    {
                      val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                      if (x7.ne(null))
                        if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                          {
                            val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                            if (x10.ne(null))
                              matchEnd11(x3.sym())
                            else
                              case13()
                          }
                        else
                          case13()
                      else
                        case13()
                    }
                  else
                    case13()
                else
                  case13()
              }
            else
              case13()
          };
          case13(){
            matchEnd11(throw new MatchError(x1))
          };
          matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
            x
          }
        };
        def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
          case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
          case10(){
            if (x1.ne(null))
              {
                val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
                if (o12.isEmpty().unary_!())
                  if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                    {
                      val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                      if (x7.ne(null))
                        if (x7.effects().isInstanceOf[List]())
                          {
                            val x8: List = (x7.effects().asInstanceOf[List](): List);
                            matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                                def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                  $anonfun.super.<init>();
                                  ()
                                };
                                final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                  case <synthetic> val x1: Option = x$1;
                                  case11(){
                                    if (x1.isInstanceOf[Some]())
                                      {
                                        val x2: Some = (x1.asInstanceOf[Some](): Some);
                                        if (x2.ne(null))
                                          if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                            {
                                              val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                              if (x4.ne(null))
                                                if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                  {
                                                    val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                    if (x7.ne(null))
                                                      if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                        {
                                                          val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                          if (x9.ne(null))
                                                            if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                              matchEnd10(x4)
                                                            else
                                                              case12()
                                                          else
                                                            case12()
                                                        }
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              else
                                                case12()
                                            }
                                          else
                                            case12()
                                        else
                                          case12()
                                      }
                                    else
                                      case12()
                                  };
                                  case12(){
                                    matchEnd10(default.apply(x$1))
                                  };
                                  matchEnd10(x: Object){
                                    x
                                  }
                                };
                                final def isDefinedAt(x$1: Option): Boolean = {
                                  case <synthetic> val x1: Option = x$1;
                                  case11(){
                                    if (x1.isInstanceOf[Some]())
                                      {
                                        val x2: Some = (x1.asInstanceOf[Some](): Some);
                                        if (x2.ne(null))
                                          if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                            {
                                              val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                              if (x4.ne(null))
                                                if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                  {
                                                    val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                    if (x7.ne(null))
                                                      if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                        {
                                                          val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                          if (x9.ne(null))
                                                            if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                              matchEnd10(true)
                                                            else
                                                              case12()
                                                          else
                                                            case12()
                                                        }
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              else
                                                case12()
                                            }
                                          else
                                            case12()
                                        else
                                          case12()
                                      }
                                    else
                                      case12()
                                  };
                                  case12(){
                                    matchEnd10(false)
                                  };
                                  matchEnd10(x: Boolean){
                                    x
                                  }
                                };
                                <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                                final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                              };
                              new anonymous class $anonfun($anonfun.this)
                            }, immutable.this.List.canBuildFrom()))
                          }
                        else
                          case11()
                      else
                        case11()
                    }
                  else
                    case11()
                else
                  case11()
              }
            else
              case11()
          };
          case11(){
            matchEnd9(throw new MatchError(x1))
          };
          matchEnd9(x: List){
            x
          }
        };
        val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
        val pvss: List = pvs.map({
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
            def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
            <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
          };
          (new anonymous class $anonfun($anonfun.this): Function1)
        }, immutable.this.List.canBuildFrom());
        def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
          case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
          case8(){
            if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
              {
                val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                if (x3.ne(null))
                  if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                    {
                      val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                      if (x5.ne(null))
                        if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                          {
                            val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                            if (x6.ne(null))
                              if (pvss.contains(x3.sym()))
                                matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                              else
                                case9()
                            else
                              case9()
                          }
                        else
                          case9()
                      else
                        case9()
                    }
                  else
                    case9()
                else
                  case9()
              }
            else
              case9()
          };
          case9(){
            matchEnd7(x1)
          };
          matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
            x
          }
        };
        $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
          {
            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
              def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
              <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
              final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
            };
            (new anonymous class $anonfun($anonfun.this): Function1)
          }
        }, immutable.this.List.canBuildFrom()));
        $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
          {
            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
              def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
              <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
              final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
            };
            (new anonymous class $anonfun($anonfun.this): Function1)
          }
        }, immutable.this.List.canBuildFrom()))
      };
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
      final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
    };
    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
  });
  SplitEffectsExpFat$class.this.__ifThenElse({
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
      <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
      final <bridge> def apply(): Object = $anonfun.this.apply()
    };
    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
  }, {
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, $anonfun.this.$outer.projectPureWithSimpleB(x3.cond(), reflect.this.Manifest.Boolean()), $anonfun.this.$outer.projectSimpleB(x3.body())), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 70)})))));
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
      final <bridge> def apply(): Object = $anonfun.this.apply()
    };
    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
  }, {
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(): Unit = $anonfun.this.apply$mcV$sp();
      <specialized> def apply$mcV$sp(): Unit = ();
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
      final <bridge> def apply(): Object = $anonfun.this.apply()
    };
    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
  });
  new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
}
exception when typing matchEnd5({
  val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
  affected.foreach({
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
        val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
        val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
        $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
        val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
          case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
          case12(){
            if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
              {
                val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                if (x3.ne(null))
                  if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                    {
                      val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                      if (x7.ne(null))
                        if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                          {
                            val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                            if (x10.ne(null))
                              matchEnd11(x3.sym())
                            else
                              case13()
                          }
                        else
                          case13()
                      else
                        case13()
                    }
                  else
                    case13()
                else
                  case13()
              }
            else
              case13()
          };
          case13(){
            matchEnd11(throw new MatchError(x1))
          };
          matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
            x
          }
        };
        def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
          case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
          case10(){
            if (x1.ne(null))
              {
                val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
                if (o12.isEmpty().unary_!())
                  if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                    {
                      val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                      if (x7.ne(null))
                        if (x7.effects().isInstanceOf[List]())
                          {
                            val x8: List = (x7.effects().asInstanceOf[List](): List);
                            matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                                def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                  $anonfun.super.<init>();
                                  ()
                                };
                                final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                  case <synthetic> val x1: Option = x$1;
                                  case11(){
                                    if (x1.isInstanceOf[Some]())
                                      {
                                        val x2: Some = (x1.asInstanceOf[Some](): Some);
                                        if (x2.ne(null))
                                          if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                            {
                                              val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                              if (x4.ne(null))
                                                if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                  {
                                                    val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                    if (x7.ne(null))
                                                      if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                        {
                                                          val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                          if (x9.ne(null))
                                                            if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                              matchEnd10(x4)
                                                            else
                                                              case12()
                                                          else
                                                            case12()
                                                        }
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              else
                                                case12()
                                            }
                                          else
                                            case12()
                                        else
                                          case12()
                                      }
                                    else
                                      case12()
                                  };
                                  case12(){
                                    matchEnd10(default.apply(x$1))
                                  };
                                  matchEnd10(x: Object){
                                    x
                                  }
                                };
                                final def isDefinedAt(x$1: Option): Boolean = {
                                  case <synthetic> val x1: Option = x$1;
                                  case11(){
                                    if (x1.isInstanceOf[Some]())
                                      {
                                        val x2: Some = (x1.asInstanceOf[Some](): Some);
                                        if (x2.ne(null))
                                          if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                            {
                                              val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                              if (x4.ne(null))
                                                if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                  {
                                                    val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                    if (x7.ne(null))
                                                      if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                        {
                                                          val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                          if (x9.ne(null))
                                                            if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                              matchEnd10(true)
                                                            else
                                                              case12()
                                                          else
                                                            case12()
                                                        }
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              else
                                                case12()
                                            }
                                          else
                                            case12()
                                        else
                                          case12()
                                      }
                                    else
                                      case12()
                                  };
                                  case12(){
                                    matchEnd10(false)
                                  };
                                  matchEnd10(x: Boolean){
                                    x
                                  }
                                };
                                <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                                final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                              };
                              new anonymous class $anonfun($anonfun.this)
                            }, immutable.this.List.canBuildFrom()))
                          }
                        else
                          case11()
                      else
                        case11()
                    }
                  else
                    case11()
                else
                  case11()
              }
            else
              case11()
          };
          case11(){
            matchEnd9(throw new MatchError(x1))
          };
          matchEnd9(x: List){
            x
          }
        };
        val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
        val pvss: List = pvs.map({
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
            def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
            <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
          };
          (new anonymous class $anonfun($anonfun.this): Function1)
        }, immutable.this.List.canBuildFrom());
        def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
          case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
          case8(){
            if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
              {
                val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                if (x3.ne(null))
                  if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                    {
                      val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                      if (x5.ne(null))
                        if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                          {
                            val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                            if (x6.ne(null))
                              if (pvss.contains(x3.sym()))
                                matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                              else
                                case9()
                            else
                              case9()
                          }
                        else
                          case9()
                      else
                        case9()
                    }
                  else
                    case9()
                else
                  case9()
              }
            else
              case9()
          };
          case9(){
            matchEnd7(x1)
          };
          matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
            x
          }
        };
        $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
          {
            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
              def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
              <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
              final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
            };
            (new anonymous class $anonfun($anonfun.this): Function1)
          }
        }, immutable.this.List.canBuildFrom()));
        $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
          {
            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
              def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
              <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
              final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
            };
            (new anonymous class $anonfun($anonfun.this): Function1)
          }
        }, immutable.this.List.canBuildFrom()))
      };
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
      final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
    };
    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
  });
  SplitEffectsExpFat$class.this.__ifThenElse({
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
      <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
      final <bridge> def apply(): Object = $anonfun.this.apply()
    };
    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
  }, {
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, $anonfun.this.$outer.projectPureWithSimpleB(x3.cond(), reflect.this.Manifest.Boolean()), $anonfun.this.$outer.projectSimpleB(x3.body())), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 70)})))));
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
      final <bridge> def apply(): Object = $anonfun.this.apply()
    };
    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
  }, {
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(): Unit = $anonfun.this.apply$mcV$sp();
      <specialized> def apply$mcV$sp(): Unit = ();
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
      final <bridge> def apply(): Object = $anonfun.this.apply()
    };
    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
  });
  new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
})
exception when typing if (x3.ne(null))
  matchEnd5({
    val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
    affected.foreach({
      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
        def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
          val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
          val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
          $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
          val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
            case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
            case12(){
              if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                {
                  val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                  if (x3.ne(null))
                    if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                      {
                        val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                        if (x7.ne(null))
                          if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                            {
                              val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                              if (x10.ne(null))
                                matchEnd11(x3.sym())
                              else
                                case13()
                            }
                          else
                            case13()
                        else
                          case13()
                      }
                    else
                      case13()
                  else
                    case13()
                }
              else
                case13()
            };
            case13(){
              matchEnd11(throw new MatchError(x1))
            };
            matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
              x
            }
          };
          def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
            case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
            case10(){
              if (x1.ne(null))
                {
                  val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
                  if (o12.isEmpty().unary_!())
                    if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                      {
                        val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                        if (x7.ne(null))
                          if (x7.effects().isInstanceOf[List]())
                            {
                              val x8: List = (x7.effects().asInstanceOf[List](): List);
                              matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                    case <synthetic> val x1: Option = x$1;
                                    case11(){
                                      if (x1.isInstanceOf[Some]())
                                        {
                                          val x2: Some = (x1.asInstanceOf[Some](): Some);
                                          if (x2.ne(null))
                                            if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                              {
                                                val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                if (x4.ne(null))
                                                  if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                    {
                                                      val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                      if (x7.ne(null))
                                                        if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                          {
                                                            val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                            if (x9.ne(null))
                                                              if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                matchEnd10(x4)
                                                              else
                                                                case12()
                                                            else
                                                              case12()
                                                          }
                                                        else
                                                          case12()
                                                      else
                                                        case12()
                                                    }
                                                  else
                                                    case12()
                                                else
                                                  case12()
                                              }
                                            else
                                              case12()
                                          else
                                            case12()
                                        }
                                      else
                                        case12()
                                    };
                                    case12(){
                                      matchEnd10(default.apply(x$1))
                                    };
                                    matchEnd10(x: Object){
                                      x
                                    }
                                  };
                                  final def isDefinedAt(x$1: Option): Boolean = {
                                    case <synthetic> val x1: Option = x$1;
                                    case11(){
                                      if (x1.isInstanceOf[Some]())
                                        {
                                          val x2: Some = (x1.asInstanceOf[Some](): Some);
                                          if (x2.ne(null))
                                            if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                              {
                                                val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                if (x4.ne(null))
                                                  if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                    {
                                                      val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                      if (x7.ne(null))
                                                        if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                          {
                                                            val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                            if (x9.ne(null))
                                                              if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                matchEnd10(true)
                                                              else
                                                                case12()
                                                            else
                                                              case12()
                                                          }
                                                        else
                                                          case12()
                                                      else
                                                        case12()
                                                    }
                                                  else
                                                    case12()
                                                else
                                                  case12()
                                              }
                                            else
                                              case12()
                                          else
                                            case12()
                                        }
                                      else
                                        case12()
                                    };
                                    case12(){
                                      matchEnd10(false)
                                    };
                                    matchEnd10(x: Boolean){
                                      x
                                    }
                                  };
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                                  final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                                };
                                new anonymous class $anonfun($anonfun.this)
                              }, immutable.this.List.canBuildFrom()))
                            }
                          else
                            case11()
                        else
                          case11()
                      }
                    else
                      case11()
                  else
                    case11()
                }
              else
                case11()
            };
            case11(){
              matchEnd9(throw new MatchError(x1))
            };
            matchEnd9(x: List){
              x
            }
          };
          val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
          val pvss: List = pvs.map({
            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
              def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
              <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
              final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
            };
            (new anonymous class $anonfun($anonfun.this): Function1)
          }, immutable.this.List.canBuildFrom());
          def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
            case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
            case8(){
              if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                {
                  val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                  if (x3.ne(null))
                    if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                      {
                        val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                        if (x5.ne(null))
                          if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                            {
                              val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                              if (x6.ne(null))
                                if (pvss.contains(x3.sym()))
                                  matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                                else
                                  case9()
                              else
                                case9()
                            }
                          else
                            case9()
                        else
                          case9()
                      }
                    else
                      case9()
                  else
                    case9()
                }
              else
                case9()
            };
            case9(){
              matchEnd7(x1)
            };
            matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
              x
            }
          };
          $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
            {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
              };
              (new anonymous class $anonfun($anonfun.this): Function1)
            }
          }, immutable.this.List.canBuildFrom()));
          $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
            {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
              };
              (new anonymous class $anonfun($anonfun.this): Function1)
            }
          }, immutable.this.List.canBuildFrom()))
        };
        <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
        final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
      };
      (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
    });
    SplitEffectsExpFat$class.this.__ifThenElse({
      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
        def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
        <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
        <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
        final <bridge> def apply(): Object = $anonfun.this.apply()
      };
      (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
    }, {
      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
        def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, $anonfun.this.$outer.projectPureWithSimpleB(x3.cond(), reflect.this.Manifest.Boolean()), $anonfun.this.$outer.projectSimpleB(x3.body())), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 70)})))));
        <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
        final <bridge> def apply(): Object = $anonfun.this.apply()
      };
      (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
    }, {
      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
        def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(): Unit = $anonfun.this.apply$mcV$sp();
        <specialized> def apply$mcV$sp(): Unit = ();
        <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
        final <bridge> def apply(): Object = $anonfun.this.apply()
      };
      (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
    });
    new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
  })
else
  case8()
exception when typing {
  val x3: scala.virtualization.lms.common.WhileExp#While = (x1.asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
  if (x3.ne(null))
    matchEnd5({
      val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
      affected.foreach({
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
          def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
            val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
            val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
            $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
            val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
              case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
              case12(){
                if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                  {
                    val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                    if (x3.ne(null))
                      if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                        {
                          val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                          if (x7.ne(null))
                            if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                              {
                                val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                                if (x10.ne(null))
                                  matchEnd11(x3.sym())
                                else
                                  case13()
                              }
                            else
                              case13()
                          else
                            case13()
                        }
                      else
                        case13()
                    else
                      case13()
                  }
                else
                  case13()
              };
              case13(){
                matchEnd11(throw new MatchError(x1))
              };
              matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
                x
              }
            };
            def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
              case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
              case10(){
                if (x1.ne(null))
                  {
                    val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
                    if (o12.isEmpty().unary_!())
                      if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                        {
                          val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                          if (x7.ne(null))
                            if (x7.effects().isInstanceOf[List]())
                              {
                                val x8: List = (x7.effects().asInstanceOf[List](): List);
                                matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                                    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                      $anonfun.super.<init>();
                                      ()
                                    };
                                    final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                      case <synthetic> val x1: Option = x$1;
                                      case11(){
                                        if (x1.isInstanceOf[Some]())
                                          {
                                            val x2: Some = (x1.asInstanceOf[Some](): Some);
                                            if (x2.ne(null))
                                              if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                {
                                                  val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                  if (x4.ne(null))
                                                    if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                      {
                                                        val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                        if (x7.ne(null))
                                                          if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                            {
                                                              val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                              if (x9.ne(null))
                                                                if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                  matchEnd10(x4)
                                                                else
                                                                  case12()
                                                              else
                                                                case12()
                                                            }
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  else
                                                    case12()
                                                }
                                              else
                                                case12()
                                            else
                                              case12()
                                          }
                                        else
                                          case12()
                                      };
                                      case12(){
                                        matchEnd10(default.apply(x$1))
                                      };
                                      matchEnd10(x: Object){
                                        x
                                      }
                                    };
                                    final def isDefinedAt(x$1: Option): Boolean = {
                                      case <synthetic> val x1: Option = x$1;
                                      case11(){
                                        if (x1.isInstanceOf[Some]())
                                          {
                                            val x2: Some = (x1.asInstanceOf[Some](): Some);
                                            if (x2.ne(null))
                                              if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                {
                                                  val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                  if (x4.ne(null))
                                                    if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                      {
                                                        val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                        if (x7.ne(null))
                                                          if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                            {
                                                              val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                              if (x9.ne(null))
                                                                if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                  matchEnd10(true)
                                                                else
                                                                  case12()
                                                              else
                                                                case12()
                                                            }
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  else
                                                    case12()
                                                }
                                              else
                                                case12()
                                            else
                                              case12()
                                          }
                                        else
                                          case12()
                                      };
                                      case12(){
                                        matchEnd10(false)
                                      };
                                      matchEnd10(x: Boolean){
                                        x
                                      }
                                    };
                                    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                    final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                                    final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                                  };
                                  new anonymous class $anonfun($anonfun.this)
                                }, immutable.this.List.canBuildFrom()))
                              }
                            else
                              case11()
                          else
                            case11()
                        }
                      else
                        case11()
                    else
                      case11()
                  }
                else
                  case11()
              };
              case11(){
                matchEnd9(throw new MatchError(x1))
              };
              matchEnd9(x: List){
                x
              }
            };
            val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
            val pvss: List = pvs.map({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
                <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
              };
              (new anonymous class $anonfun($anonfun.this): Function1)
            }, immutable.this.List.canBuildFrom());
            def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
              case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
              case8(){
                if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                  {
                    val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                    if (x3.ne(null))
                      if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                        {
                          val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                          if (x5.ne(null))
                            if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                              {
                                val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                if (x6.ne(null))
                                  if (pvss.contains(x3.sym()))
                                    matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                                  else
                                    case9()
                                else
                                  case9()
                              }
                            else
                              case9()
                          else
                            case9()
                        }
                      else
                        case9()
                    else
                      case9()
                  }
                else
                  case9()
              };
              case9(){
                matchEnd7(x1)
              };
              matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
                x
              }
            };
            $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
              {
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                };
                (new anonymous class $anonfun($anonfun.this): Function1)
              }
            }, immutable.this.List.canBuildFrom()));
            $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
              {
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                };
                (new anonymous class $anonfun($anonfun.this): Function1)
              }
            }, immutable.this.List.canBuildFrom()))
          };
          <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
          final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
          final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
        };
        (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
      });
      SplitEffectsExpFat$class.this.__ifThenElse({
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
          def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
          <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
          <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
          final <bridge> def apply(): Object = $anonfun.this.apply()
        };
        (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
      }, {
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
          def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, $anonfun.this.$outer.projectPureWithSimpleB(x3.cond(), reflect.this.Manifest.Boolean()), $anonfun.this.$outer.projectSimpleB(x3.body())), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 70)})))));
          <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
          final <bridge> def apply(): Object = $anonfun.this.apply()
        };
        (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
      }, {
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
          def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final def apply(): Unit = $anonfun.this.apply$mcV$sp();
          <specialized> def apply$mcV$sp(): Unit = ();
          <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
          final <bridge> def apply(): Object = $anonfun.this.apply()
        };
        (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
      });
      new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
    })
  else
    case8()
}
exception when typing if (x1.isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
  {
    val x3: scala.virtualization.lms.common.WhileExp#While = (x1.asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
    if (x3.ne(null))
      matchEnd5({
        val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
        affected.foreach({
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
            def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
              val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
              val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
              $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
              val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
                case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
                case12(){
                  if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                    {
                      val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                      if (x3.ne(null))
                        if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                          {
                            val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                            if (x7.ne(null))
                              if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                                {
                                  val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                                  if (x10.ne(null))
                                    matchEnd11(x3.sym())
                                  else
                                    case13()
                                }
                              else
                                case13()
                            else
                              case13()
                          }
                        else
                          case13()
                      else
                        case13()
                    }
                  else
                    case13()
                };
                case13(){
                  matchEnd11(throw new MatchError(x1))
                };
                matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
                  x
                }
              };
              def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
                case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
                case10(){
                  if (x1.ne(null))
                    {
                      val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
                      if (o12.isEmpty().unary_!())
                        if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                          {
                            val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                            if (x7.ne(null))
                              if (x7.effects().isInstanceOf[List]())
                                {
                                  val x8: List = (x7.effects().asInstanceOf[List](): List);
                                  matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                                      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                        $anonfun.super.<init>();
                                        ()
                                      };
                                      final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                        case <synthetic> val x1: Option = x$1;
                                        case11(){
                                          if (x1.isInstanceOf[Some]())
                                            {
                                              val x2: Some = (x1.asInstanceOf[Some](): Some);
                                              if (x2.ne(null))
                                                if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                  {
                                                    val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                    if (x4.ne(null))
                                                      if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                        {
                                                          val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                          if (x7.ne(null))
                                                            if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                              {
                                                                val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                if (x9.ne(null))
                                                                  if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                    matchEnd10(x4)
                                                                  else
                                                                    case12()
                                                                else
                                                                  case12()
                                                              }
                                                            else
                                                              case12()
                                                          else
                                                            case12()
                                                        }
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              else
                                                case12()
                                            }
                                          else
                                            case12()
                                        };
                                        case12(){
                                          matchEnd10(default.apply(x$1))
                                        };
                                        matchEnd10(x: Object){
                                          x
                                        }
                                      };
                                      final def isDefinedAt(x$1: Option): Boolean = {
                                        case <synthetic> val x1: Option = x$1;
                                        case11(){
                                          if (x1.isInstanceOf[Some]())
                                            {
                                              val x2: Some = (x1.asInstanceOf[Some](): Some);
                                              if (x2.ne(null))
                                                if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                  {
                                                    val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                    if (x4.ne(null))
                                                      if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                        {
                                                          val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                          if (x7.ne(null))
                                                            if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                              {
                                                                val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                if (x9.ne(null))
                                                                  if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                    matchEnd10(true)
                                                                  else
                                                                    case12()
                                                                else
                                                                  case12()
                                                              }
                                                            else
                                                              case12()
                                                          else
                                                            case12()
                                                        }
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              else
                                                case12()
                                            }
                                          else
                                            case12()
                                        };
                                        case12(){
                                          matchEnd10(false)
                                        };
                                        matchEnd10(x: Boolean){
                                          x
                                        }
                                      };
                                      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                      final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                                      final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                                    };
                                    new anonymous class $anonfun($anonfun.this)
                                  }, immutable.this.List.canBuildFrom()))
                                }
                              else
                                case11()
                            else
                              case11()
                          }
                        else
                          case11()
                      else
                        case11()
                    }
                  else
                    case11()
                };
                case11(){
                  matchEnd9(throw new MatchError(x1))
                };
                matchEnd9(x: List){
                  x
                }
              };
              val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
              val pvss: List = pvs.map({
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                };
                (new anonymous class $anonfun($anonfun.this): Function1)
              }, immutable.this.List.canBuildFrom());
              def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
                case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
                case8(){
                  if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                    {
                      val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                      if (x3.ne(null))
                        if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                          {
                            val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                            if (x5.ne(null))
                              if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                {
                                  val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                  if (x6.ne(null))
                                    if (pvss.contains(x3.sym()))
                                      matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                                    else
                                      case9()
                                  else
                                    case9()
                                }
                              else
                                case9()
                            else
                              case9()
                          }
                        else
                          case9()
                      else
                        case9()
                    }
                  else
                    case9()
                };
                case9(){
                  matchEnd7(x1)
                };
                matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
                  x
                }
              };
              $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
                {
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                  };
                  (new anonymous class $anonfun($anonfun.this): Function1)
                }
              }, immutable.this.List.canBuildFrom()));
              $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
                {
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                  };
                  (new anonymous class $anonfun($anonfun.this): Function1)
                }
              }, immutable.this.List.canBuildFrom()))
            };
            <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
            final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
          };
          (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
        });
        SplitEffectsExpFat$class.this.__ifThenElse({
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
            def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
            <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
            <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
            final <bridge> def apply(): Object = $anonfun.this.apply()
          };
          (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
        }, {
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
            def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, $anonfun.this.$outer.projectPureWithSimpleB(x3.cond(), reflect.this.Manifest.Boolean()), $anonfun.this.$outer.projectSimpleB(x3.body())), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 70)})))));
            <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
            final <bridge> def apply(): Object = $anonfun.this.apply()
          };
          (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
        }, {
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
            def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(): Unit = $anonfun.this.apply$mcV$sp();
            <specialized> def apply$mcV$sp(): Unit = ();
            <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
            final <bridge> def apply(): Object = $anonfun.this.apply()
          };
          (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
        });
        new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
      })
    else
      case8()
  }
else
  case8()
exception when typing case7(){
  if (x1.isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
    {
      val x3: scala.virtualization.lms.common.WhileExp#While = (x1.asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
      if (x3.ne(null))
        matchEnd5({
          val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
          affected.foreach({
            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
              def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
                val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
                val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
                $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
                val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
                  case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
                  case12(){
                    if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                      {
                        val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                        if (x3.ne(null))
                          if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                            {
                              val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                              if (x7.ne(null))
                                if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                                  {
                                    val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                                    if (x10.ne(null))
                                      matchEnd11(x3.sym())
                                    else
                                      case13()
                                  }
                                else
                                  case13()
                              else
                                case13()
                            }
                          else
                            case13()
                        else
                          case13()
                      }
                    else
                      case13()
                  };
                  case13(){
                    matchEnd11(throw new MatchError(x1))
                  };
                  matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
                    x
                  }
                };
                def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
                  case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
                  case10(){
                    if (x1.ne(null))
                      {
                        val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
                        if (o12.isEmpty().unary_!())
                          if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                            {
                              val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                              if (x7.ne(null))
                                if (x7.effects().isInstanceOf[List]())
                                  {
                                    val x8: List = (x7.effects().asInstanceOf[List](): List);
                                    matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                                      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                                        def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                          $anonfun.super.<init>();
                                          ()
                                        };
                                        final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                          case <synthetic> val x1: Option = x$1;
                                          case11(){
                                            if (x1.isInstanceOf[Some]())
                                              {
                                                val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                if (x2.ne(null))
                                                  if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                    {
                                                      val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                      if (x4.ne(null))
                                                        if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                          {
                                                            val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                            if (x7.ne(null))
                                                              if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                {
                                                                  val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                  if (x9.ne(null))
                                                                    if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                      matchEnd10(x4)
                                                                    else
                                                                      case12()
                                                                  else
                                                                    case12()
                                                                }
                                                              else
                                                                case12()
                                                            else
                                                              case12()
                                                          }
                                                        else
                                                          case12()
                                                      else
                                                        case12()
                                                    }
                                                  else
                                                    case12()
                                                else
                                                  case12()
                                              }
                                            else
                                              case12()
                                          };
                                          case12(){
                                            matchEnd10(default.apply(x$1))
                                          };
                                          matchEnd10(x: Object){
                                            x
                                          }
                                        };
                                        final def isDefinedAt(x$1: Option): Boolean = {
                                          case <synthetic> val x1: Option = x$1;
                                          case11(){
                                            if (x1.isInstanceOf[Some]())
                                              {
                                                val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                if (x2.ne(null))
                                                  if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                    {
                                                      val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                      if (x4.ne(null))
                                                        if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                          {
                                                            val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                            if (x7.ne(null))
                                                              if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                {
                                                                  val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                  if (x9.ne(null))
                                                                    if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                      matchEnd10(true)
                                                                    else
                                                                      case12()
                                                                  else
                                                                    case12()
                                                                }
                                                              else
                                                                case12()
                                                            else
                                                              case12()
                                                          }
                                                        else
                                                          case12()
                                                      else
                                                        case12()
                                                    }
                                                  else
                                                    case12()
                                                else
                                                  case12()
                                              }
                                            else
                                              case12()
                                          };
                                          case12(){
                                            matchEnd10(false)
                                          };
                                          matchEnd10(x: Boolean){
                                            x
                                          }
                                        };
                                        <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                        final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                                        final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                                      };
                                      new anonymous class $anonfun($anonfun.this)
                                    }, immutable.this.List.canBuildFrom()))
                                  }
                                else
                                  case11()
                              else
                                case11()
                            }
                          else
                            case11()
                        else
                          case11()
                      }
                    else
                      case11()
                  };
                  case11(){
                    matchEnd9(throw new MatchError(x1))
                  };
                  matchEnd9(x: List){
                    x
                  }
                };
                val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
                val pvss: List = pvs.map({
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
                    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                  };
                  (new anonymous class $anonfun($anonfun.this): Function1)
                }, immutable.this.List.canBuildFrom());
                def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
                  case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
                  case8(){
                    if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                      {
                        val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                        if (x3.ne(null))
                          if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                            {
                              val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                              if (x5.ne(null))
                                if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                  {
                                    val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                    if (x6.ne(null))
                                      if (pvss.contains(x3.sym()))
                                        matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                                      else
                                        case9()
                                    else
                                      case9()
                                  }
                                else
                                  case9()
                              else
                                case9()
                            }
                          else
                            case9()
                        else
                          case9()
                      }
                    else
                      case9()
                  };
                  case9(){
                    matchEnd7(x1)
                  };
                  matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
                    x
                  }
                };
                $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
                  {
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                    };
                    (new anonymous class $anonfun($anonfun.this): Function1)
                  }
                }, immutable.this.List.canBuildFrom()));
                $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
                  {
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                    };
                    (new anonymous class $anonfun($anonfun.this): Function1)
                  }
                }, immutable.this.List.canBuildFrom()))
              };
              <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
              final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
              final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
            };
            (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
          });
          SplitEffectsExpFat$class.this.__ifThenElse({
            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
              def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
              <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
              <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
              final <bridge> def apply(): Object = $anonfun.this.apply()
            };
            (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
          }, {
            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
              def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, $anonfun.this.$outer.projectPureWithSimpleB(x3.cond(), reflect.this.Manifest.Boolean()), $anonfun.this.$outer.projectSimpleB(x3.body())), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 70)})))));
              <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
              final <bridge> def apply(): Object = $anonfun.this.apply()
            };
            (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
          }, {
            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
              def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(): Unit = $anonfun.this.apply$mcV$sp();
              <specialized> def apply$mcV$sp(): Unit = ();
              <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
              final <bridge> def apply(): Object = $anonfun.this.apply()
            };
            (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
          });
          new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
        })
      else
        case8()
    }
  else
    case8()
}
exception when typing {
  case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Def = x;
  case6(){
    if (x1.isInstanceOf[scala.virtualization.lms.common.IfThenElseExp#IfThenElse]())
      {
        val x2: scala.virtualization.lms.common.IfThenElseExp#IfThenElse = (x1.asInstanceOf[scala.virtualization.lms.common.IfThenElseExp#IfThenElse](): scala.virtualization.lms.common.IfThenElseExp#IfThenElse);
        if (x2.ne(null))
          matchEnd5({
            val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
            affected.foreach({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse($anonfun.this.$outer, x2.cond(), $anonfun.this.$outer.projectB(x2.thenp(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), $anonfun.this.$outer.projectB(x2.elsep(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit()), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 26)})))));
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
            });
            SplitEffectsExpFat$class.this.__ifThenElse({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse($anonfun.this.$outer, x2.cond(), $anonfun.this.$outer.projectSimpleB(x2.thenp()), $anonfun.this.$outer.projectSimpleB(x2.elsep()), reflect.this.Manifest.Unit()), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 29)})))));
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                <specialized> def apply$mcV$sp(): Unit = ();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            });
            SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse(SplitEffectsExpFat$class.this, x2.cond(), SplitEffectsExpFat$class.this.projectPureB(x2.thenp()), SplitEffectsExpFat$class.this.projectPureB(x2.elsep()), evidence$1), SplitEffectsExpFat$class.this.projectPureS(u), evidence$1, pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 31)})))))
          })
        else
          case7()
      }
    else
      case7()
  };
  case7(){
    if (x1.isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
      {
        val x3: scala.virtualization.lms.common.WhileExp#While = (x1.asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
        if (x3.ne(null))
          matchEnd5({
            val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
            affected.foreach({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
                  val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
                  val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
                  $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
                  val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
                    case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
                    case12(){
                      if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                        {
                          val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                          if (x3.ne(null))
                            if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                              {
                                val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                if (x7.ne(null))
                                  if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                                    {
                                      val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                                      if (x10.ne(null))
                                        matchEnd11(x3.sym())
                                      else
                                        case13()
                                    }
                                  else
                                    case13()
                                else
                                  case13()
                              }
                            else
                              case13()
                          else
                            case13()
                        }
                      else
                        case13()
                    };
                    case13(){
                      matchEnd11(throw new MatchError(x1))
                    };
                    matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
                      x
                    }
                  };
                  def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
                    case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
                    case10(){
                      if (x1.ne(null))
                        {
                          val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
                          if (o12.isEmpty().unary_!())
                            if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                              {
                                val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                                if (x7.ne(null))
                                  if (x7.effects().isInstanceOf[List]())
                                    {
                                      val x8: List = (x7.effects().asInstanceOf[List](): List);
                                      matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                                        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                                          def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                            $anonfun.super.<init>();
                                            ()
                                          };
                                          final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                            case <synthetic> val x1: Option = x$1;
                                            case11(){
                                              if (x1.isInstanceOf[Some]())
                                                {
                                                  val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                  if (x2.ne(null))
                                                    if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                      {
                                                        val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                        if (x4.ne(null))
                                                          if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                            {
                                                              val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                              if (x7.ne(null))
                                                                if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                  {
                                                                    val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                    if (x9.ne(null))
                                                                      if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                        matchEnd10(x4)
                                                                      else
                                                                        case12()
                                                                    else
                                                                      case12()
                                                                  }
                                                                else
                                                                  case12()
                                                              else
                                                                case12()
                                                            }
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  else
                                                    case12()
                                                }
                                              else
                                                case12()
                                            };
                                            case12(){
                                              matchEnd10(default.apply(x$1))
                                            };
                                            matchEnd10(x: Object){
                                              x
                                            }
                                          };
                                          final def isDefinedAt(x$1: Option): Boolean = {
                                            case <synthetic> val x1: Option = x$1;
                                            case11(){
                                              if (x1.isInstanceOf[Some]())
                                                {
                                                  val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                  if (x2.ne(null))
                                                    if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                      {
                                                        val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                        if (x4.ne(null))
                                                          if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                            {
                                                              val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                              if (x7.ne(null))
                                                                if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                  {
                                                                    val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                    if (x9.ne(null))
                                                                      if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                        matchEnd10(true)
                                                                      else
                                                                        case12()
                                                                    else
                                                                      case12()
                                                                  }
                                                                else
                                                                  case12()
                                                              else
                                                                case12()
                                                            }
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  else
                                                    case12()
                                                }
                                              else
                                                case12()
                                            };
                                            case12(){
                                              matchEnd10(false)
                                            };
                                            matchEnd10(x: Boolean){
                                              x
                                            }
                                          };
                                          <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                          final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                                          final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                                        };
                                        new anonymous class $anonfun($anonfun.this)
                                      }, immutable.this.List.canBuildFrom()))
                                    }
                                  else
                                    case11()
                                else
                                  case11()
                              }
                            else
                              case11()
                          else
                            case11()
                        }
                      else
                        case11()
                    };
                    case11(){
                      matchEnd9(throw new MatchError(x1))
                    };
                    matchEnd9(x: List){
                      x
                    }
                  };
                  val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
                  val pvss: List = pvs.map({
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
                      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                    };
                    (new anonymous class $anonfun($anonfun.this): Function1)
                  }, immutable.this.List.canBuildFrom());
                  def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
                    case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
                    case8(){
                      if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                        {
                          val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                          if (x3.ne(null))
                            if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                              {
                                val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                if (x5.ne(null))
                                  if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                    {
                                      val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                      if (x6.ne(null))
                                        if (pvss.contains(x3.sym()))
                                          matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                                        else
                                          case9()
                                      else
                                        case9()
                                    }
                                  else
                                    case9()
                                else
                                  case9()
                              }
                            else
                              case9()
                          else
                            case9()
                        }
                      else
                        case9()
                    };
                    case9(){
                      matchEnd7(x1)
                    };
                    matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
                      x
                    }
                  };
                  $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
                    {
                      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                        def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                          $anonfun.super.<init>();
                          ()
                        };
                        final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                        <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                      };
                      (new anonymous class $anonfun($anonfun.this): Function1)
                    }
                  }, immutable.this.List.canBuildFrom()));
                  $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
                    {
                      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                        def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                          $anonfun.super.<init>();
                          ()
                        };
                        final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                        <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                      };
                      (new anonymous class $anonfun($anonfun.this): Function1)
                    }
                  }, immutable.this.List.canBuildFrom()))
                };
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
                final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
            });
            SplitEffectsExpFat$class.this.__ifThenElse({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, $anonfun.this.$outer.projectPureWithSimpleB(x3.cond(), reflect.this.Manifest.Boolean()), $anonfun.this.$outer.projectSimpleB(x3.body())), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 70)})))));
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                <specialized> def apply$mcV$sp(): Unit = ();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            });
            new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
          })
        else
          case8()
      }
    else
      case8()
  };
  case8(){
    if (x1.isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
      {
        val x4: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x1.asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
        if (x4.ne(null))
          matchEnd5({
            val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
            affected.foreach({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x4.k()), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 80)})))));
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
            });
            SplitEffectsExpFat$class.this.__ifThenElse({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x4.k()), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 83)})))));
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                <specialized> def apply$mcV$sp(): Unit = ();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            });
            new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
          })
        else
          case9()
      }
    else
      case9()
  };
  case9(){
    matchEnd5(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(x, u, evidence$1, pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 87)}))))))
  };
  matchEnd5(x){
    x
  }
}
exception when typing override def reflectEffectInternal(x: scala.virtualization.lms.internal.Expressions#Def, u: scala.virtualization.lms.internal.Effects#Summary, evidence$1: scala.reflect.Manifest, pos: scala.reflect.SourceContext): scala.virtualization.lms.internal.Expressions#Exp = {
  case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Def = x;
  case6(){
    if (x1.isInstanceOf[scala.virtualization.lms.common.IfThenElseExp#IfThenElse]())
      {
        val x2: scala.virtualization.lms.common.IfThenElseExp#IfThenElse = (x1.asInstanceOf[scala.virtualization.lms.common.IfThenElseExp#IfThenElse](): scala.virtualization.lms.common.IfThenElseExp#IfThenElse);
        if (x2.ne(null))
          matchEnd5({
            val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
            affected.foreach({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse($anonfun.this.$outer, x2.cond(), $anonfun.this.$outer.projectB(x2.thenp(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), $anonfun.this.$outer.projectB(x2.elsep(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit()), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 26)})))));
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
            });
            SplitEffectsExpFat$class.this.__ifThenElse({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse($anonfun.this.$outer, x2.cond(), $anonfun.this.$outer.projectSimpleB(x2.thenp()), $anonfun.this.$outer.projectSimpleB(x2.elsep()), reflect.this.Manifest.Unit()), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 29)})))));
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                <specialized> def apply$mcV$sp(): Unit = ();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            });
            SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse(SplitEffectsExpFat$class.this, x2.cond(), SplitEffectsExpFat$class.this.projectPureB(x2.thenp()), SplitEffectsExpFat$class.this.projectPureB(x2.elsep()), evidence$1), SplitEffectsExpFat$class.this.projectPureS(u), evidence$1, pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 31)})))))
          })
        else
          case7()
      }
    else
      case7()
  };
  case7(){
    if (x1.isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
      {
        val x3: scala.virtualization.lms.common.WhileExp#While = (x1.asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
        if (x3.ne(null))
          matchEnd5({
            val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
            affected.foreach({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
                  val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
                  val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
                  $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
                  val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
                    case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
                    case12(){
                      if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                        {
                          val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                          if (x3.ne(null))
                            if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                              {
                                val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                if (x7.ne(null))
                                  if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                                    {
                                      val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                                      if (x10.ne(null))
                                        matchEnd11(x3.sym())
                                      else
                                        case13()
                                    }
                                  else
                                    case13()
                                else
                                  case13()
                              }
                            else
                              case13()
                          else
                            case13()
                        }
                      else
                        case13()
                    };
                    case13(){
                      matchEnd11(throw new MatchError(x1))
                    };
                    matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
                      x
                    }
                  };
                  def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
                    case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
                    case10(){
                      if (x1.ne(null))
                        {
                          val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
                          if (o12.isEmpty().unary_!())
                            if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                              {
                                val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                                if (x7.ne(null))
                                  if (x7.effects().isInstanceOf[List]())
                                    {
                                      val x8: List = (x7.effects().asInstanceOf[List](): List);
                                      matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                                        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                                          def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                            $anonfun.super.<init>();
                                            ()
                                          };
                                          final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                            case <synthetic> val x1: Option = x$1;
                                            case11(){
                                              if (x1.isInstanceOf[Some]())
                                                {
                                                  val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                  if (x2.ne(null))
                                                    if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                      {
                                                        val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                        if (x4.ne(null))
                                                          if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                            {
                                                              val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                              if (x7.ne(null))
                                                                if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                  {
                                                                    val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                    if (x9.ne(null))
                                                                      if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                        matchEnd10(x4)
                                                                      else
                                                                        case12()
                                                                    else
                                                                      case12()
                                                                  }
                                                                else
                                                                  case12()
                                                              else
                                                                case12()
                                                            }
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  else
                                                    case12()
                                                }
                                              else
                                                case12()
                                            };
                                            case12(){
                                              matchEnd10(default.apply(x$1))
                                            };
                                            matchEnd10(x: Object){
                                              x
                                            }
                                          };
                                          final def isDefinedAt(x$1: Option): Boolean = {
                                            case <synthetic> val x1: Option = x$1;
                                            case11(){
                                              if (x1.isInstanceOf[Some]())
                                                {
                                                  val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                  if (x2.ne(null))
                                                    if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                      {
                                                        val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                        if (x4.ne(null))
                                                          if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                            {
                                                              val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                              if (x7.ne(null))
                                                                if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                  {
                                                                    val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                    if (x9.ne(null))
                                                                      if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                        matchEnd10(true)
                                                                      else
                                                                        case12()
                                                                    else
                                                                      case12()
                                                                  }
                                                                else
                                                                  case12()
                                                              else
                                                                case12()
                                                            }
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  else
                                                    case12()
                                                }
                                              else
                                                case12()
                                            };
                                            case12(){
                                              matchEnd10(false)
                                            };
                                            matchEnd10(x: Boolean){
                                              x
                                            }
                                          };
                                          <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                          final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                                          final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                                        };
                                        new anonymous class $anonfun($anonfun.this)
                                      }, immutable.this.List.canBuildFrom()))
                                    }
                                  else
                                    case11()
                                else
                                  case11()
                              }
                            else
                              case11()
                          else
                            case11()
                        }
                      else
                        case11()
                    };
                    case11(){
                      matchEnd9(throw new MatchError(x1))
                    };
                    matchEnd9(x: List){
                      x
                    }
                  };
                  val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
                  val pvss: List = pvs.map({
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
                      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                    };
                    (new anonymous class $anonfun($anonfun.this): Function1)
                  }, immutable.this.List.canBuildFrom());
                  def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
                    case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
                    case8(){
                      if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                        {
                          val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                          if (x3.ne(null))
                            if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                              {
                                val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                if (x5.ne(null))
                                  if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                    {
                                      val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                      if (x6.ne(null))
                                        if (pvss.contains(x3.sym()))
                                          matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                                        else
                                          case9()
                                      else
                                        case9()
                                    }
                                  else
                                    case9()
                                else
                                  case9()
                              }
                            else
                              case9()
                          else
                            case9()
                        }
                      else
                        case9()
                    };
                    case9(){
                      matchEnd7(x1)
                    };
                    matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
                      x
                    }
                  };
                  $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
                    {
                      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                        def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                          $anonfun.super.<init>();
                          ()
                        };
                        final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                        <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                      };
                      (new anonymous class $anonfun($anonfun.this): Function1)
                    }
                  }, immutable.this.List.canBuildFrom()));
                  $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
                    {
                      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                        def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                          $anonfun.super.<init>();
                          ()
                        };
                        final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                        <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                      };
                      (new anonymous class $anonfun($anonfun.this): Function1)
                    }
                  }, immutable.this.List.canBuildFrom()))
                };
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
                final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
            });
            SplitEffectsExpFat$class.this.__ifThenElse({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, $anonfun.this.$outer.projectPureWithSimpleB(x3.cond(), reflect.this.Manifest.Boolean()), $anonfun.this.$outer.projectSimpleB(x3.body())), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 70)})))));
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                <specialized> def apply$mcV$sp(): Unit = ();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            });
            new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
          })
        else
          case8()
      }
    else
      case8()
  };
  case8(){
    if (x1.isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
      {
        val x4: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x1.asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
        if (x4.ne(null))
          matchEnd5({
            val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
            affected.foreach({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x4.k()), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 80)})))));
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
            });
            SplitEffectsExpFat$class.this.__ifThenElse({
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x4.k()), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 83)})))));
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            }, {
              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                  $anonfun.super.<init>();
                  ()
                };
                final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                <specialized> def apply$mcV$sp(): Unit = ();
                <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                final <bridge> def apply(): Object = $anonfun.this.apply()
              };
              (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
            });
            new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
          })
        else
          case9()
      }
    else
      case9()
  };
  case9(){
    matchEnd5(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(x, u, evidence$1, pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 87)}))))))
  };
  matchEnd5(x){
    x
  }
}
exception when typing abstract trait SplitEffectsExpFat$class extends Object with scala.virtualization.lms.common.IfThenElseFatExp$class with scala.virtualization.lms.common.WhileExp$class with scala.virtualization.lms.common.PreviousIterationDummyExp$class with scala.virtualization.lms.common.SplitEffectsExpFat { `this`: scala.virtualization.lms.common.BooleanOpsExp => 
  def /*SplitEffectsExpFat$class*/$init$(): Unit = {
    ()
  };
  override def reflectEffectInternal(x: scala.virtualization.lms.internal.Expressions#Def, u: scala.virtualization.lms.internal.Effects#Summary, evidence$1: scala.reflect.Manifest, pos: scala.reflect.SourceContext): scala.virtualization.lms.internal.Expressions#Exp = {
    case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Def = x;
    case6(){
      if (x1.isInstanceOf[scala.virtualization.lms.common.IfThenElseExp#IfThenElse]())
        {
          val x2: scala.virtualization.lms.common.IfThenElseExp#IfThenElse = (x1.asInstanceOf[scala.virtualization.lms.common.IfThenElseExp#IfThenElse](): scala.virtualization.lms.common.IfThenElseExp#IfThenElse);
          if (x2.ne(null))
            matchEnd5({
              val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
              affected.foreach({
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse($anonfun.this.$outer, x2.cond(), $anonfun.this.$outer.projectB(x2.thenp(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), $anonfun.this.$outer.projectB(x2.elsep(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit()), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 26)})))));
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
              });
              SplitEffectsExpFat$class.this.__ifThenElse({
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                  <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(): Object = $anonfun.this.apply()
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
              }, {
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse($anonfun.this.$outer, x2.cond(), $anonfun.this.$outer.projectSimpleB(x2.thenp()), $anonfun.this.$outer.projectSimpleB(x2.elsep()), reflect.this.Manifest.Unit()), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 29)})))));
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(): Object = $anonfun.this.apply()
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
              }, {
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                  <specialized> def apply$mcV$sp(): Unit = ();
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(): Object = $anonfun.this.apply()
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
              });
              SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse(SplitEffectsExpFat$class.this, x2.cond(), SplitEffectsExpFat$class.this.projectPureB(x2.thenp()), SplitEffectsExpFat$class.this.projectPureB(x2.elsep()), evidence$1), SplitEffectsExpFat$class.this.projectPureS(u), evidence$1, pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 31)})))))
            })
          else
            case7()
        }
      else
        case7()
    };
    case7(){
      if (x1.isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
        {
          val x3: scala.virtualization.lms.common.WhileExp#While = (x1.asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
          if (x3.ne(null))
            matchEnd5({
              val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
              affected.foreach({
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
                    val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
                    val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
                    $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
                    val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
                      case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
                      case12(){
                        if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                          {
                            val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                            if (x3.ne(null))
                              if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                {
                                  val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                  if (x7.ne(null))
                                    if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                                      {
                                        val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                                        if (x10.ne(null))
                                          matchEnd11(x3.sym())
                                        else
                                          case13()
                                      }
                                    else
                                      case13()
                                  else
                                    case13()
                                }
                              else
                                case13()
                            else
                              case13()
                          }
                        else
                          case13()
                      };
                      case13(){
                        matchEnd11(throw new MatchError(x1))
                      };
                      matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
                        x
                      }
                    };
                    def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
                      case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
                      case10(){
                        if (x1.ne(null))
                          {
                            val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
                            if (o12.isEmpty().unary_!())
                              if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                                {
                                  val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                                  if (x7.ne(null))
                                    if (x7.effects().isInstanceOf[List]())
                                      {
                                        val x8: List = (x7.effects().asInstanceOf[List](): List);
                                        matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                                          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                                            def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                              $anonfun.super.<init>();
                                              ()
                                            };
                                            final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                              case <synthetic> val x1: Option = x$1;
                                              case11(){
                                                if (x1.isInstanceOf[Some]())
                                                  {
                                                    val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                    if (x2.ne(null))
                                                      if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                        {
                                                          val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                          if (x4.ne(null))
                                                            if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                              {
                                                                val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                                if (x7.ne(null))
                                                                  if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                    {
                                                                      val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                      if (x9.ne(null))
                                                                        if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                          matchEnd10(x4)
                                                                        else
                                                                          case12()
                                                                      else
                                                                        case12()
                                                                    }
                                                                  else
                                                                    case12()
                                                                else
                                                                  case12()
                                                              }
                                                            else
                                                              case12()
                                                          else
                                                            case12()
                                                        }
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              };
                                              case12(){
                                                matchEnd10(default.apply(x$1))
                                              };
                                              matchEnd10(x: Object){
                                                x
                                              }
                                            };
                                            final def isDefinedAt(x$1: Option): Boolean = {
                                              case <synthetic> val x1: Option = x$1;
                                              case11(){
                                                if (x1.isInstanceOf[Some]())
                                                  {
                                                    val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                    if (x2.ne(null))
                                                      if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                        {
                                                          val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                          if (x4.ne(null))
                                                            if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                              {
                                                                val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                                if (x7.ne(null))
                                                                  if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                    {
                                                                      val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                      if (x9.ne(null))
                                                                        if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                          matchEnd10(true)
                                                                        else
                                                                          case12()
                                                                      else
                                                                        case12()
                                                                    }
                                                                  else
                                                                    case12()
                                                                else
                                                                  case12()
                                                              }
                                                            else
                                                              case12()
                                                          else
                                                            case12()
                                                        }
                                                      else
                                                        case12()
                                                    else
                                                      case12()
                                                  }
                                                else
                                                  case12()
                                              };
                                              case12(){
                                                matchEnd10(false)
                                              };
                                              matchEnd10(x: Boolean){
                                                x
                                              }
                                            };
                                            <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                            final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                                            final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                                          };
                                          new anonymous class $anonfun($anonfun.this)
                                        }, immutable.this.List.canBuildFrom()))
                                      }
                                    else
                                      case11()
                                  else
                                    case11()
                                }
                              else
                                case11()
                            else
                              case11()
                          }
                        else
                          case11()
                      };
                      case11(){
                        matchEnd9(throw new MatchError(x1))
                      };
                      matchEnd9(x: List){
                        x
                      }
                    };
                    val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
                    val pvss: List = pvs.map({
                      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                        def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                          $anonfun.super.<init>();
                          ()
                        };
                        final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
                        <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                      };
                      (new anonymous class $anonfun($anonfun.this): Function1)
                    }, immutable.this.List.canBuildFrom());
                    def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
                      case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
                      case8(){
                        if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                          {
                            val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                            if (x3.ne(null))
                              if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                {
                                  val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                  if (x5.ne(null))
                                    if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                      {
                                        val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                        if (x6.ne(null))
                                          if (pvss.contains(x3.sym()))
                                            matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                                          else
                                            case9()
                                        else
                                          case9()
                                      }
                                    else
                                      case9()
                                  else
                                    case9()
                                }
                              else
                                case9()
                            else
                              case9()
                          }
                        else
                          case9()
                      };
                      case9(){
                        matchEnd7(x1)
                      };
                      matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
                        x
                      }
                    };
                    $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
                      {
                        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                          def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                            $anonfun.super.<init>();
                            ()
                          };
                          final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                          <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                          final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                        };
                        (new anonymous class $anonfun($anonfun.this): Function1)
                      }
                    }, immutable.this.List.canBuildFrom()));
                    $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
                      {
                        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                          def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                            $anonfun.super.<init>();
                            ()
                          };
                          final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                          <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                          final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                        };
                        (new anonymous class $anonfun($anonfun.this): Function1)
                      }
                    }, immutable.this.List.canBuildFrom()))
                  };
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
                  final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
              });
              SplitEffectsExpFat$class.this.__ifThenElse({
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                  <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(): Object = $anonfun.this.apply()
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
              }, {
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, $anonfun.this.$outer.projectPureWithSimpleB(x3.cond(), reflect.this.Manifest.Boolean()), $anonfun.this.$outer.projectSimpleB(x3.body())), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 70)})))));
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(): Object = $anonfun.this.apply()
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
              }, {
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                  <specialized> def apply$mcV$sp(): Unit = ();
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(): Object = $anonfun.this.apply()
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
              });
              new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
            })
          else
            case8()
        }
      else
        case8()
    };
    case8(){
      if (x1.isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
        {
          val x4: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x1.asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
          if (x4.ne(null))
            matchEnd5({
              val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
              affected.foreach({
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x4.k()), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 80)})))));
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
              });
              SplitEffectsExpFat$class.this.__ifThenElse({
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                  <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(): Object = $anonfun.this.apply()
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
              }, {
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x4.k()), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 83)})))));
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(): Object = $anonfun.this.apply()
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
              }, {
                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                  def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                    $anonfun.super.<init>();
                    ()
                  };
                  final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                  <specialized> def apply$mcV$sp(): Unit = ();
                  <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                  <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                  final <bridge> def apply(): Object = $anonfun.this.apply()
                };
                (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
              });
              new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
            })
          else
            case9()
        }
      else
        case9()
    };
    case9(){
      matchEnd5(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(x, u, evidence$1, pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 87)}))))))
    };
    matchEnd5(x){
      x
    }
  };
  def projectL(a: List, s: List): List = a.filter({
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcZL$sp with Serializable {
      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(x$2: scala.virtualization.lms.internal.Expressions#Sym): Boolean = s.contains(x$2);
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
      final <bridge> def apply(v1: Object): Boolean = $anonfun.this.apply(v1)
    };
    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
  });
  def projectS(u: scala.virtualization.lms.internal.Effects#Summary, s: List): scala.virtualization.lms.internal.Effects#Summary = {
    val qual$2: scala.virtualization.lms.internal.Effects#Summary = SplitEffectsExpFat$class.this.Pure();
    val x$26: List = SplitEffectsExpFat$class.this.projectL(u.mayRead(), s);
    val x$27: List = SplitEffectsExpFat$class.this.projectL(u.mstRead(), s);
    val x$28: List = SplitEffectsExpFat$class.this.projectL(u.mayWrite(), s);
    val x$29: List = SplitEffectsExpFat$class.this.projectL(u.mstWrite(), s);
    val x$30: Boolean = qual$2.copy$default$1();
    val x$31: Boolean = qual$2.copy$default$2();
    val x$32: Boolean = qual$2.copy$default$3();
    val x$33: Boolean = qual$2.copy$default$4();
    val x$34: Boolean = qual$2.copy$default$5();
    qual$2.copy(x$30, x$31, x$32, x$33, x$34, x$26, x$27, x$28, x$29)
  };
  def projectB(b: scala.virtualization.lms.internal.Blocks#Block, s: List): scala.virtualization.lms.internal.Blocks#Block = {
    case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
    case7(){
      if (x1.ne(null))
        {
          val o9: Option = SplitEffectsExpFat$class.this.Def().unapply(x1.res());
          if (o9.isEmpty().unary_!())
            if (o9.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
              {
                val x5: scala.virtualization.lms.internal.Effects#Reify = (o9.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                if (x5.ne(null))
                  matchEnd6({
                    val deps: List = SplitEffectsExpFat$class.this.calculateDependencies(x5.effects(), SplitEffectsExpFat$class.this.Write(s));
                    new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()), SplitEffectsExpFat$class.this.projectS(x5.summary(), s), deps), reflect.this.Manifest.Unit(), reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 103)})))))
                  })
                else
                  case8()
              }
            else
              case8()
          else
            case8()
        }
      else
        case8()
    };
    case8(){
      matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit())))
    };
    matchEnd6(x){
      x
    }
  };
  def projectSimpleS(u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Effects#Summary = {
    val qual$1: scala.virtualization.lms.internal.Effects#Summary = SplitEffectsExpFat$class.this.Pure();
    val x$17: Boolean = u.maySimple();
    val x$18: Boolean = u.mstSimple();
    val x$19: Boolean = qual$1.copy$default$3();
    val x$20: Boolean = qual$1.copy$default$4();
    val x$21: Boolean = qual$1.copy$default$5();
    val x$22: List = qual$1.copy$default$6();
    val x$23: List = qual$1.copy$default$7();
    val x$24: List = qual$1.copy$default$8();
    val x$25: List = qual$1.copy$default$9();
    qual$1.copy(x$17, x$18, x$19, x$20, x$21, x$22, x$23, x$24, x$25)
  };
  def projectSimpleB(b: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Blocks#Block = {
    case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
    case7(){
      if (x1.ne(null))
        {
          val o9: Option = SplitEffectsExpFat$class.this.Def().unapply(x1.res());
          if (o9.isEmpty().unary_!())
            if (o9.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
              {
                val x5: scala.virtualization.lms.internal.Effects#Reify = (o9.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                if (x5.ne(null))
                  matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()), SplitEffectsExpFat$class.this.projectSimpleS(x5.summary()), SplitEffectsExpFat$class.this.calculateDependencies(x5.effects(), SplitEffectsExpFat$class.this.Simple())), reflect.this.Manifest.Unit(), reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 110)}))))))
                else
                  case8()
              }
            else
              case8()
          else
            case8()
        }
      else
        case8()
    };
    case8(){
      matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit())))
    };
    matchEnd6(x){
      x
    }
  };
  def projectPureS(u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Effects#Summary = SplitEffectsExpFat$class.this.Pure();
  def projectPureB(b: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Blocks#Block = {
    case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
    case7(){
      if (x1.ne(null))
        {
          val o9: Option = SplitEffectsExpFat$class.this.Def().unapply(x1.res());
          if (o9.isEmpty().unary_!())
            if (o9.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
              {
                val x5: scala.virtualization.lms.internal.Effects#Reify = (o9.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                if (x5.ne(null))
                  matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, x5.x()))
                else
                  case8()
              }
            else
              case8()
          else
            case8()
        }
      else
        case8()
    };
    case8(){
      matchEnd6(b)
    };
    matchEnd6(x){
      x
    }
  };
  def projectPureWithB(b: scala.virtualization.lms.internal.Blocks#Block, s: List, evidence$2: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block = {
    case <synthetic> val x1: Tuple2 = new Tuple2(SplitEffectsExpFat$class.this.projectPureB(b), SplitEffectsExpFat$class.this.projectB(b, s));
    case14(){
      if (x1.ne(null))
        if (x1._1().ne(null))
          if (x1._2().ne(null))
            {
              val o16: Option = SplitEffectsExpFat$class.this.Def().unapply(x1._2().res());
              if (o16.isEmpty().unary_!())
                if (o16.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                  {
                    val x8: scala.virtualization.lms.internal.Effects#Reify = (o16.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                    if (x8.ne(null))
                      if (x8.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#Const]())
                        {
                          val x10: scala.virtualization.lms.internal.Expressions#Const = (x8.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#Const](): scala.virtualization.lms.internal.Expressions#Const);
                          if (x10.ne(null))
                            if (().==(x10.x()))
                              {
                                val x12: scala.runtime.BoxedUnit = x10.x();
                                matchEnd13(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, x1._1().res(), x8.summary(), x8.effects()), evidence$2, reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 122)}))))))
                              }
                            else
                              case15()
                          else
                            case15()
                        }
                      else
                        case15()
                    else
                      case15()
                  }
                else
                  case15()
              else
                case15()
            }
          else
            case15()
        else
          case15()
      else
        case15()
    };
    case15(){
      if (x1.ne(null))
        matchEnd13(x1._1())
      else
        case17()
    };
    case17(){
      matchEnd13(throw new MatchError(x1))
    };
    matchEnd13(x){
      x
    }
  };
  def projectPureWithSimpleB(b: scala.virtualization.lms.internal.Blocks#Block, evidence$3: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block = {
    case <synthetic> val x1: Tuple2 = new Tuple2(SplitEffectsExpFat$class.this.projectPureB(b), SplitEffectsExpFat$class.this.projectSimpleB(b));
    case14(){
      if (x1.ne(null))
        if (x1._1().ne(null))
          if (x1._2().ne(null))
            {
              val o16: Option = SplitEffectsExpFat$class.this.Def().unapply(x1._2().res());
              if (o16.isEmpty().unary_!())
                if (o16.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                  {
                    val x8: scala.virtualization.lms.internal.Effects#Reify = (o16.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                    if (x8.ne(null))
                      if (x8.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#Const]())
                        {
                          val x10: scala.virtualization.lms.internal.Expressions#Const = (x8.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#Const](): scala.virtualization.lms.internal.Expressions#Const);
                          if (x10.ne(null))
                            if (().==(x10.x()))
                              {
                                val x12: scala.runtime.BoxedUnit = x10.x();
                                matchEnd13(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, x1._1().res(), x8.summary(), x8.effects()), evidence$3, reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 128)}))))))
                              }
                            else
                              case15()
                          else
                            case15()
                        }
                      else
                        case15()
                    else
                      case15()
                  }
                else
                  case15()
              else
                case15()
            }
          else
            case15()
        else
          case15()
      else
        case15()
    };
    case15(){
      if (x1.ne(null))
        matchEnd13(x1._1())
      else
        case17()
    };
    case17(){
      matchEnd13(throw new MatchError(x1))
    };
    matchEnd13(x){
      x
    }
  };
  @volatile <synthetic> var scala$virtualization$lms$common$SplitEffectsExpFat$$SimpleFatWhile$module: ... = _;
  <synthetic> <stable> def SimpleFatWhile(): ... = new ...(SplitEffectsExpFat$class.this);
  override def syms(e: Object): List = {
    case <synthetic> val x1: Object = e;
    case4(){
      if (x1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().&&((x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile).scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer().eq(SplitEffectsExpFat$class.this)))
        {
          val x2: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
          if (x2.ne(null))
            matchEnd3(SplitEffectsExpFat$class.this.syms(x2.cond()).++(SplitEffectsExpFat$class.this.syms(x2.body()), immutable.this.List.canBuildFrom()).++(SplitEffectsExpFat$class.this.syms(x2.extradeps()), immutable.this.List.canBuildFrom()))
          else
            case5()
        }
      else
        case5()
    };
    case5(){
      matchEnd3(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$syms(e))
    };
    matchEnd3(x){
      x
    }
  };
  override def boundSyms(e: Object): List = {
    case <synthetic> val x1: Object = e;
    case4(){
      if (x1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().&&((x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile).scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer().eq(SplitEffectsExpFat$class.this)))
        {
          val x2: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
          if (x2.ne(null))
            matchEnd3({
              <synthetic> val x$3: List = SplitEffectsExpFat$class.this.effectSyms(x2.cond());
              SplitEffectsExpFat$class.this.effectSyms(x2.body()).:::(x$3)
            })
          else
            case5()
        }
      else
        case5()
    };
    case5(){
      matchEnd3(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$boundSyms(e))
    };
    matchEnd3(x){
      x
    }
  };
  override def symsFreq(e: Object): List = {
    case <synthetic> val x1: Object = e;
    case4(){
      if (x1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().&&((x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile).scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer().eq(SplitEffectsExpFat$class.this)))
        {
          val x2: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
          if (x2.ne(null))
            matchEnd3(SplitEffectsExpFat$class.this.freqHot(x2.cond()).++(SplitEffectsExpFat$class.this.freqHot(x2.body()), immutable.this.List.canBuildFrom()).++(SplitEffectsExpFat$class.this.freqNormal(x2.extradeps()), immutable.this.List.canBuildFrom()))
          else
            case5()
        }
      else
        case5()
    };
    case5(){
      matchEnd3(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$symsFreq(e))
    };
    matchEnd3(x){
      x
    }
  }
}
exception when typing package common {
  abstract trait SplitEffectsExpFat extends Object with scala.virtualization.lms.common.IfThenElseFatExp with scala.virtualization.lms.common.WhileExp with scala.virtualization.lms.common.PreviousIterationDummyExp { `this`: scala.virtualization.lms.common.BooleanOpsExp => 
    final <superaccessor> def scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(x: scala.virtualization.lms.internal.Expressions#Def, u: scala.virtualization.lms.internal.Effects#Summary, evidence$7: scala.reflect.Manifest, pos: scala.reflect.SourceContext): scala.virtualization.lms.internal.Expressions#Exp;
    final <superaccessor> def scala$virtualization$lms$common$SplitEffectsExpFat$$super$syms(e: Object): List;
    final <superaccessor> def scala$virtualization$lms$common$SplitEffectsExpFat$$super$boundSyms(e: Object): List;
    final <superaccessor> def scala$virtualization$lms$common$SplitEffectsExpFat$$super$symsFreq(e: Object): List;
    override def reflectEffectInternal(x: scala.virtualization.lms.internal.Expressions#Def, u: scala.virtualization.lms.internal.Effects#Summary, evidence$1: scala.reflect.Manifest, pos: scala.reflect.SourceContext): scala.virtualization.lms.internal.Expressions#Exp;
    def projectL(a: List, s: List): List;
    def projectS(u: scala.virtualization.lms.internal.Effects#Summary, s: List): scala.virtualization.lms.internal.Effects#Summary;
    def projectB(b: scala.virtualization.lms.internal.Blocks#Block, s: List): scala.virtualization.lms.internal.Blocks#Block;
    def projectSimpleS(u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Effects#Summary;
    def projectSimpleB(b: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Blocks#Block;
    def projectPureS(u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Effects#Summary;
    def projectPureB(b: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Blocks#Block;
    def projectPureWithB(b: scala.virtualization.lms.internal.Blocks#Block, s: List, evidence$2: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block;
    def projectPureWithSimpleB(b: scala.virtualization.lms.internal.Blocks#Block, evidence$3: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block;
    case class SimpleFatWhile extends scala.virtualization.lms.internal.FatExpressions#FatDef with Product with Serializable {
      <caseaccessor> <paramaccessor> private[this] val cond: scala.virtualization.lms.internal.Blocks#Block = _;
      <stable> <caseaccessor> <accessor> <paramaccessor> def cond(): scala.virtualization.lms.internal.Blocks#Block = SimpleFatWhile.this.cond;
      <caseaccessor> <paramaccessor> private[this] val body: List = _;
      <stable> <caseaccessor> <accessor> <paramaccessor> def body(): List = SimpleFatWhile.this.body;
      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp, cond: scala.virtualization.lms.internal.Blocks#Block, body: List): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = {
        SimpleFatWhile.super.<init>($outer);
        SimpleFatWhile.this./*Product$class*/$init$();
        ()
      };
      private[this] var extradeps: List = immutable.this.Nil;
      <accessor> def extradeps(): List = SimpleFatWhile.this.extradeps;
      <accessor> def extradeps_=(x$1: List): Unit = SimpleFatWhile.this.extradeps = x$1;
      <synthetic> def copy(cond: scala.virtualization.lms.internal.Blocks#Block = cond, body: List = body): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = new scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile(SimpleFatWhile.this.scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer(), cond, body);
      <synthetic> def copy$default$1(): scala.virtualization.lms.internal.Blocks#Block = SimpleFatWhile.this.cond();
      <synthetic> def copy$default$2(): List = SimpleFatWhile.this.body();
      override <synthetic> def productPrefix(): String = "SimpleFatWhile";
      <synthetic> def productArity(): Int = 2;
      <synthetic> def productElement(x$1: Int): Object = {
        case <synthetic> val x1: Int = x$1;
        (x1: Int) match {
          case 0 => SimpleFatWhile.this.cond()
          case 1 => SimpleFatWhile.this.body()
          case _ => throw new IndexOutOfBoundsException(x$1.toString())
        }
      };
      override <synthetic> def productIterator(): Iterator = runtime.this.ScalaRunTime.typedProductIterator(SimpleFatWhile.this);
      <synthetic> def canEqual(x$1: Object): Boolean = x$1.$isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]();
      <synthetic> def _1(): scala.virtualization.lms.internal.Blocks#Block = SimpleFatWhile.this.cond();
      <synthetic> def _2(): List = SimpleFatWhile.this.body();
      override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(SimpleFatWhile.this);
      override <synthetic> def toString(): String = ScalaRunTime.this._toString(SimpleFatWhile.this);
      override <synthetic> def equals(x$1: Object): Boolean = SimpleFatWhile.this.eq(x$1.asInstanceOf[Object]()).||(x$1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().&&({
        <synthetic> val SimpleFatWhile$1: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = x$1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]();
        SimpleFatWhile.this.cond().==(SimpleFatWhile$1.cond()).&&(SimpleFatWhile.this.body().==(SimpleFatWhile$1.body())).&&(SimpleFatWhile$1.canEqual(SimpleFatWhile.this))
      }));
      <synthetic> <paramaccessor> protected val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = SimpleFatWhile.this.$outer
    };
    <synthetic> object SimpleFatWhile extends scala.runtime.AbstractFunction2 with Serializable {
      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): ... = {
        SimpleFatWhile.super.<init>();
        ()
      };
      final override def toString(): String = "SimpleFatWhile";
      case <synthetic> def apply(cond: scala.virtualization.lms.internal.Blocks#Block, body: List): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = new scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile(SimpleFatWhile.this.$outer, cond, body);
      case <synthetic> def unapply(x$0: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile): Option = if (x$0.==(null))
        scala.this.None
      else
        new Some(new Tuple2(x$0.cond(), x$0.body()));
      <synthetic> private def readResolve(): Object = SimpleFatWhile.this.$outer.SimpleFatWhile();
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = SimpleFatWhile.this.$outer;
      case <synthetic> <bridge> def apply(v1: Object, v2: Object): Object = SimpleFatWhile.this.apply(v1, v2)
    };
    <synthetic> <stable> def SimpleFatWhile(): ...;
    override def syms(e: Object): List;
    override def boundSyms(e: Object): List;
    override def symsFreq(e: Object): List
  };
  abstract trait PreviousIterationDummyExp extends Object with scala.virtualization.lms.common.BaseFatExp with scala.virtualization.lms.common.EffectExp {
    case class PreviousIteration extends scala.virtualization.lms.internal.Expressions#Def with Product with Serializable {
      <caseaccessor> <paramaccessor> private[this] val k: scala.virtualization.lms.internal.Expressions#Exp = _;
      <stable> <caseaccessor> <accessor> <paramaccessor> def k(): scala.virtualization.lms.internal.Expressions#Exp = PreviousIteration.this.k;
      def <init>($outer: scala.virtualization.lms.common.PreviousIterationDummyExp, k: scala.virtualization.lms.internal.Expressions#Exp): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = {
        PreviousIteration.super.<init>($outer);
        PreviousIteration.this./*Product$class*/$init$();
        ()
      };
      <synthetic> def copy(k: scala.virtualization.lms.internal.Expressions#Exp = k): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration(PreviousIteration.this.scala$virtualization$lms$common$PreviousIterationDummyExp$PreviousIteration$$$outer(), k);
      <synthetic> def copy$default$1(): scala.virtualization.lms.internal.Expressions#Exp = PreviousIteration.this.k();
      override <synthetic> def productPrefix(): String = "PreviousIteration";
      <synthetic> def productArity(): Int = 1;
      <synthetic> def productElement(x$1: Int): Object = {
        case <synthetic> val x1: Int = x$1;
        case4(){
          if (0.==(x1))
            {
              val x2: Int = x1;
              matchEnd3(PreviousIteration.this.k())
            }
          else
            case5()
        };
        case5(){
          matchEnd3(throw new IndexOutOfBoundsException(x$1.toString()))
        };
        matchEnd3(x: Object){
          x
        }
      };
      override <synthetic> def productIterator(): Iterator = runtime.this.ScalaRunTime.typedProductIterator(PreviousIteration.this);
      <synthetic> def canEqual(x$1: Object): Boolean = x$1.$isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]();
      <synthetic> def _1(): scala.virtualization.lms.internal.Expressions#Exp = PreviousIteration.this.k();
      override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(PreviousIteration.this);
      override <synthetic> def toString(): String = ScalaRunTime.this._toString(PreviousIteration.this);
      override <synthetic> def equals(x$1: Object): Boolean = PreviousIteration.this.eq(x$1.asInstanceOf[Object]()).||(x$1.isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]().&&({
        <synthetic> val PreviousIteration$1: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = x$1.asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]();
        PreviousIteration.this.k().==(PreviousIteration$1.k()).&&(PreviousIteration$1.canEqual(PreviousIteration.this))
      }));
      <synthetic> <paramaccessor> protected val $outer: scala.virtualization.lms.common.PreviousIterationDummyExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$PreviousIterationDummyExp$PreviousIteration$$$outer(): scala.virtualization.lms.common.PreviousIterationDummyExp = PreviousIteration.this.$outer
    };
    <synthetic> object PreviousIteration extends scala.runtime.AbstractFunction1 with Serializable {
      def <init>($outer: scala.virtualization.lms.common.PreviousIterationDummyExp): ... = {
        PreviousIteration.super.<init>();
        ()
      };
      final override def toString(): String = "PreviousIteration";
      case <synthetic> def apply(k: scala.virtualization.lms.internal.Expressions#Exp): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration(PreviousIteration.this.$outer, k);
      case <synthetic> def unapply(x$0: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration): Option = if (x$0.==(null))
        scala.this.None
      else
        new Some(x$0.k());
      <synthetic> private def readResolve(): Object = PreviousIteration.this.$outer.PreviousIteration();
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.PreviousIterationDummyExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$PreviousIterationDummyExp$PreviousIteration$$$outer(): scala.virtualization.lms.common.PreviousIterationDummyExp = PreviousIteration.this.$outer;
      case <synthetic> <bridge> def apply(v1: Object): Object = PreviousIteration.this.apply(v1)
    };
    <synthetic> <stable> def PreviousIteration(): ...;
    case class SimpleFatPrevious extends scala.virtualization.lms.internal.FatExpressions#FatDef with Product with Serializable {
      <caseaccessor> <paramaccessor> private[this] val k: scala.virtualization.lms.internal.Expressions#Exp = _;
      <stable> <caseaccessor> <accessor> <paramaccessor> def k(): scala.virtualization.lms.internal.Expressions#Exp = SimpleFatPrevious.this.k;
      <caseaccessor> <paramaccessor> private[this] val extra: List = _;
      <stable> <caseaccessor> <accessor> <paramaccessor> def extra(): List = SimpleFatPrevious.this.extra;
      def <init>($outer: scala.virtualization.lms.common.PreviousIterationDummyExp, k: scala.virtualization.lms.internal.Expressions#Exp, extra: List): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = {
        SimpleFatPrevious.super.<init>($outer);
        SimpleFatPrevious.this./*Product$class*/$init$();
        ()
      };
      <synthetic> def copy(k: scala.virtualization.lms.internal.Expressions#Exp = k, extra: List = extra): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = new scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious(SimpleFatPrevious.this.scala$virtualization$lms$common$PreviousIterationDummyExp$SimpleFatPrevious$$$outer(), k, extra);
      <synthetic> def copy$default$1(): scala.virtualization.lms.internal.Expressions#Exp = SimpleFatPrevious.this.k();
      <synthetic> def copy$default$2(): List = SimpleFatPrevious.this.extra();
      override <synthetic> def productPrefix(): String = "SimpleFatPrevious";
      <synthetic> def productArity(): Int = 2;
      <synthetic> def productElement(x$1: Int): Object = {
        case <synthetic> val x1: Int = x$1;
        (x1: Int) match {
          case 0 => SimpleFatPrevious.this.k()
          case 1 => SimpleFatPrevious.this.extra()
          case _ => throw new IndexOutOfBoundsException(x$1.toString())
        }
      };
      override <synthetic> def productIterator(): Iterator = runtime.this.ScalaRunTime.typedProductIterator(SimpleFatPrevious.this);
      <synthetic> def canEqual(x$1: Object): Boolean = x$1.$isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]();
      <synthetic> def _1(): scala.virtualization.lms.internal.Expressions#Exp = SimpleFatPrevious.this.k();
      <synthetic> def _2(): List = SimpleFatPrevious.this.extra();
      override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(SimpleFatPrevious.this);
      override <synthetic> def toString(): String = ScalaRunTime.this._toString(SimpleFatPrevious.this);
      override <synthetic> def equals(x$1: Object): Boolean = SimpleFatPrevious.this.eq(x$1.asInstanceOf[Object]()).||(x$1.isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]().&&({
        <synthetic> val SimpleFatPrevious$1: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = x$1.asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]();
        SimpleFatPrevious.this.k().==(SimpleFatPrevious$1.k()).&&(SimpleFatPrevious.this.extra().==(SimpleFatPrevious$1.extra())).&&(SimpleFatPrevious$1.canEqual(SimpleFatPrevious.this))
      }));
      <synthetic> <paramaccessor> protected val $outer: scala.virtualization.lms.common.PreviousIterationDummyExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$PreviousIterationDummyExp$SimpleFatPrevious$$$outer(): scala.virtualization.lms.common.PreviousIterationDummyExp = SimpleFatPrevious.this.$outer
    };
    <synthetic> object SimpleFatPrevious extends scala.runtime.AbstractFunction2 with Serializable {
      def <init>($outer: scala.virtualization.lms.common.PreviousIterationDummyExp): ... = {
        SimpleFatPrevious.super.<init>();
        ()
      };
      final override def toString(): String = "SimpleFatPrevious";
      case <synthetic> def apply(k: scala.virtualization.lms.internal.Expressions#Exp, extra: List): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = new scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious(SimpleFatPrevious.this.$outer, k, extra);
      case <synthetic> def unapply(x$0: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious): Option = if (x$0.==(null))
        scala.this.None
      else
        new Some(new Tuple2(x$0.k(), x$0.extra()));
      <synthetic> private def readResolve(): Object = SimpleFatPrevious.this.$outer.SimpleFatPrevious();
      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.PreviousIterationDummyExp = _;
      <synthetic> <stable> def scala$virtualization$lms$common$PreviousIterationDummyExp$SimpleFatPrevious$$$outer(): scala.virtualization.lms.common.PreviousIterationDummyExp = SimpleFatPrevious.this.$outer;
      case <synthetic> <bridge> def apply(v1: Object, v2: Object): Object = SimpleFatPrevious.this.apply(v1, v2)
    };
    <synthetic> <stable> def SimpleFatPrevious(): ...;
    def reflectPreviousDummy(k: scala.virtualization.lms.internal.Expressions#Exp, u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Expressions#Exp
  };
  abstract trait BaseGenSplitEffects extends Object with scala.virtualization.lms.common.BaseGenIfThenElseFat with scala.virtualization.lms.internal.GenericFatCodegen {
    final <superaccessor> def scala$virtualization$lms$common$BaseGenSplitEffects$$super$reifyBlock(x: Function0, evidence$2: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block;
    final <superaccessor> def scala$virtualization$lms$common$BaseGenSplitEffects$$super$fatten(e: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm;
    final <superaccessor> def scala$virtualization$lms$common$BaseGenSplitEffects$$super$fattenAll(e: List): List;
    final <superaccessor> def scala$virtualization$lms$common$BaseGenSplitEffects$$super$emitFatNode(sym: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit;
    <stable> <accessor> def IR(): scala.virtualization.lms.common.SplitEffectsExpFat;
    override def reifyBlock(x: Function0, evidence$4: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block;
    override def fatten(e: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm;
    override def fattenAll(e: List): List;
    override def emitFatNode(symList: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit
  };
  abstract trait ScalaGenSplitEffects extends Object with scala.virtualization.lms.common.BaseGenSplitEffects with scala.virtualization.lms.common.ScalaGenIfThenElseFat {
    <stable> <accessor> def IR(): scala.virtualization.lms.common.SplitEffectsExpFat
  };
  abstract trait ScalaGenPreviousIterationDummy extends Object with scala.virtualization.lms.common.ScalaGenFat {
    final <superaccessor> def scala$virtualization$lms$common$ScalaGenPreviousIterationDummy$$super$emitNode(sym: scala.virtualization.lms.internal.Expressions#Sym, rhs: scala.virtualization.lms.internal.Expressions#Def): Unit;
    final <superaccessor> def scala$virtualization$lms$common$ScalaGenPreviousIterationDummy$$super$emitFatNode(sym: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit;
    <stable> <accessor> def IR(): scala.virtualization.lms.common.PreviousIterationDummyExp;
    override def emitNode(sym: scala.virtualization.lms.internal.Expressions#Sym, rhs: scala.virtualization.lms.internal.Expressions#Def): Unit;
    override def emitFatNode(symList: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit
  };
  abstract trait SplitEffectsExpFat$class extends Object with scala.virtualization.lms.common.IfThenElseFatExp$class with scala.virtualization.lms.common.WhileExp$class with scala.virtualization.lms.common.PreviousIterationDummyExp$class with scala.virtualization.lms.common.SplitEffectsExpFat { `this`: scala.virtualization.lms.common.BooleanOpsExp => 
    def /*SplitEffectsExpFat$class*/$init$(): Unit = {
      ()
    };
    override def reflectEffectInternal(x: scala.virtualization.lms.internal.Expressions#Def, u: scala.virtualization.lms.internal.Effects#Summary, evidence$1: scala.reflect.Manifest, pos: scala.reflect.SourceContext): scala.virtualization.lms.internal.Expressions#Exp = {
      case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Def = x;
      case6(){
        if (x1.isInstanceOf[scala.virtualization.lms.common.IfThenElseExp#IfThenElse]())
          {
            val x2: scala.virtualization.lms.common.IfThenElseExp#IfThenElse = (x1.asInstanceOf[scala.virtualization.lms.common.IfThenElseExp#IfThenElse](): scala.virtualization.lms.common.IfThenElseExp#IfThenElse);
            if (x2.ne(null))
              matchEnd5({
                val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
                affected.foreach({
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse($anonfun.this.$outer, x2.cond(), $anonfun.this.$outer.projectB(x2.thenp(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), $anonfun.this.$outer.projectB(x2.elsep(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit()), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 26)})))));
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
                });
                SplitEffectsExpFat$class.this.__ifThenElse({
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                    <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                }, {
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse($anonfun.this.$outer, x2.cond(), $anonfun.this.$outer.projectSimpleB(x2.thenp()), $anonfun.this.$outer.projectSimpleB(x2.elsep()), reflect.this.Manifest.Unit()), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 29)})))));
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                }, {
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                    <specialized> def apply$mcV$sp(): Unit = ();
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                });
                SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse(SplitEffectsExpFat$class.this, x2.cond(), SplitEffectsExpFat$class.this.projectPureB(x2.thenp()), SplitEffectsExpFat$class.this.projectPureB(x2.elsep()), evidence$1), SplitEffectsExpFat$class.this.projectPureS(u), evidence$1, pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 31)})))))
              })
            else
              case7()
          }
        else
          case7()
      };
      case7(){
        if (x1.isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
          {
            val x3: scala.virtualization.lms.common.WhileExp#While = (x1.asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
            if (x3.ne(null))
              matchEnd5({
                val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
                affected.foreach({
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
                      val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
                      val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
                      $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
                      val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
                        case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
                        case12(){
                          if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                            {
                              val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                              if (x3.ne(null))
                                if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                  {
                                    val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                    if (x7.ne(null))
                                      if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                                        {
                                          val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                                          if (x10.ne(null))
                                            matchEnd11(x3.sym())
                                          else
                                            case13()
                                        }
                                      else
                                        case13()
                                    else
                                      case13()
                                  }
                                else
                                  case13()
                              else
                                case13()
                            }
                          else
                            case13()
                        };
                        case13(){
                          matchEnd11(throw new MatchError(x1))
                        };
                        matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
                          x
                        }
                      };
                      def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
                        case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
                        case10(){
                          if (x1.ne(null))
                            {
                              val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
                              if (o12.isEmpty().unary_!())
                                if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                                  {
                                    val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                                    if (x7.ne(null))
                                      if (x7.effects().isInstanceOf[List]())
                                        {
                                          val x8: List = (x7.effects().asInstanceOf[List](): List);
                                          matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                                            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                                              def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                                $anonfun.super.<init>();
                                                ()
                                              };
                                              final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                                case <synthetic> val x1: Option = x$1;
                                                case11(){
                                                  if (x1.isInstanceOf[Some]())
                                                    {
                                                      val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                      if (x2.ne(null))
                                                        if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                          {
                                                            val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                            if (x4.ne(null))
                                                              if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                                {
                                                                  val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                                  if (x7.ne(null))
                                                                    if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                      {
                                                                        val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                        if (x9.ne(null))
                                                                          if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                            matchEnd10(x4)
                                                                          else
                                                                            case12()
                                                                        else
                                                                          case12()
                                                                      }
                                                                    else
                                                                      case12()
                                                                  else
                                                                    case12()
                                                                }
                                                              else
                                                                case12()
                                                            else
                                                              case12()
                                                          }
                                                        else
                                                          case12()
                                                      else
                                                        case12()
                                                    }
                                                  else
                                                    case12()
                                                };
                                                case12(){
                                                  matchEnd10(default.apply(x$1))
                                                };
                                                matchEnd10(x: Object){
                                                  x
                                                }
                                              };
                                              final def isDefinedAt(x$1: Option): Boolean = {
                                                case <synthetic> val x1: Option = x$1;
                                                case11(){
                                                  if (x1.isInstanceOf[Some]())
                                                    {
                                                      val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                      if (x2.ne(null))
                                                        if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                          {
                                                            val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                            if (x4.ne(null))
                                                              if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                                {
                                                                  val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                                  if (x7.ne(null))
                                                                    if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                      {
                                                                        val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                        if (x9.ne(null))
                                                                          if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                            matchEnd10(true)
                                                                          else
                                                                            case12()
                                                                        else
                                                                          case12()
                                                                      }
                                                                    else
                                                                      case12()
                                                                  else
                                                                    case12()
                                                                }
                                                              else
                                                                case12()
                                                            else
                                                              case12()
                                                          }
                                                        else
                                                          case12()
                                                      else
                                                        case12()
                                                    }
                                                  else
                                                    case12()
                                                };
                                                case12(){
                                                  matchEnd10(false)
                                                };
                                                matchEnd10(x: Boolean){
                                                  x
                                                }
                                              };
                                              <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                              final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                                              final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                                            };
                                            new anonymous class $anonfun($anonfun.this)
                                          }, immutable.this.List.canBuildFrom()))
                                        }
                                      else
                                        case11()
                                    else
                                      case11()
                                  }
                                else
                                  case11()
                              else
                                case11()
                            }
                          else
                            case11()
                        };
                        case11(){
                          matchEnd9(throw new MatchError(x1))
                        };
                        matchEnd9(x: List){
                          x
                        }
                      };
                      val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
                      val pvss: List = pvs.map({
                        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                          def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                            $anonfun.super.<init>();
                            ()
                          };
                          final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
                          <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                          final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                        };
                        (new anonymous class $anonfun($anonfun.this): Function1)
                      }, immutable.this.List.canBuildFrom());
                      def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
                        case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
                        case8(){
                          if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                            {
                              val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                              if (x3.ne(null))
                                if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                  {
                                    val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                    if (x5.ne(null))
                                      if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                        {
                                          val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                          if (x6.ne(null))
                                            if (pvss.contains(x3.sym()))
                                              matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                                            else
                                              case9()
                                          else
                                            case9()
                                        }
                                      else
                                        case9()
                                    else
                                      case9()
                                  }
                                else
                                  case9()
                              else
                                case9()
                            }
                          else
                            case9()
                        };
                        case9(){
                          matchEnd7(x1)
                        };
                        matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
                          x
                        }
                      };
                      $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
                        {
                          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                            def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                              $anonfun.super.<init>();
                              ()
                            };
                            final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                            <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                          };
                          (new anonymous class $anonfun($anonfun.this): Function1)
                        }
                      }, immutable.this.List.canBuildFrom()));
                      $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
                        {
                          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                            def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                              $anonfun.super.<init>();
                              ()
                            };
                            final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                            <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                          };
                          (new anonymous class $anonfun($anonfun.this): Function1)
                        }
                      }, immutable.this.List.canBuildFrom()))
                    };
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
                    final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
                });
                SplitEffectsExpFat$class.this.__ifThenElse({
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                    <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                }, {
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, $anonfun.this.$outer.projectPureWithSimpleB(x3.cond(), reflect.this.Manifest.Boolean()), $anonfun.this.$outer.projectSimpleB(x3.body())), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 70)})))));
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                }, {
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                    <specialized> def apply$mcV$sp(): Unit = ();
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                });
                new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
              })
            else
              case8()
          }
        else
          case8()
      };
      case8(){
        if (x1.isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
          {
            val x4: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x1.asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
            if (x4.ne(null))
              matchEnd5({
                val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
                affected.foreach({
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x4.k()), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 80)})))));
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
                });
                SplitEffectsExpFat$class.this.__ifThenElse({
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                    <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                }, {
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x4.k()), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 83)})))));
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                }, {
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                    <specialized> def apply$mcV$sp(): Unit = ();
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                });
                new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
              })
            else
              case9()
          }
        else
          case9()
      };
      case9(){
        matchEnd5(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(x, u, evidence$1, pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 87)}))))))
      };
      matchEnd5(x){
        x
      }
    };
    def projectL(a: List, s: List): List = a.filter({
      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcZL$sp with Serializable {
        def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(x$2: scala.virtualization.lms.internal.Expressions#Sym): Boolean = s.contains(x$2);
        <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
        final <bridge> def apply(v1: Object): Boolean = $anonfun.this.apply(v1)
      };
      (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
    });
    def projectS(u: scala.virtualization.lms.internal.Effects#Summary, s: List): scala.virtualization.lms.internal.Effects#Summary = {
      val qual$2: scala.virtualization.lms.internal.Effects#Summary = SplitEffectsExpFat$class.this.Pure();
      val x$26: List = SplitEffectsExpFat$class.this.projectL(u.mayRead(), s);
      val x$27: List = SplitEffectsExpFat$class.this.projectL(u.mstRead(), s);
      val x$28: List = SplitEffectsExpFat$class.this.projectL(u.mayWrite(), s);
      val x$29: List = SplitEffectsExpFat$class.this.projectL(u.mstWrite(), s);
      val x$30: Boolean = qual$2.copy$default$1();
      val x$31: Boolean = qual$2.copy$default$2();
      val x$32: Boolean = qual$2.copy$default$3();
      val x$33: Boolean = qual$2.copy$default$4();
      val x$34: Boolean = qual$2.copy$default$5();
      qual$2.copy(x$30, x$31, x$32, x$33, x$34, x$26, x$27, x$28, x$29)
    };
    def projectB(b: scala.virtualization.lms.internal.Blocks#Block, s: List): scala.virtualization.lms.internal.Blocks#Block = {
      case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
      case7(){
        if (x1.ne(null))
          {
            val o9: Option = SplitEffectsExpFat$class.this.Def().unapply(x1.res());
            if (o9.isEmpty().unary_!())
              if (o9.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                {
                  val x5: scala.virtualization.lms.internal.Effects#Reify = (o9.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                  if (x5.ne(null))
                    matchEnd6({
                      val deps: List = SplitEffectsExpFat$class.this.calculateDependencies(x5.effects(), SplitEffectsExpFat$class.this.Write(s));
                      new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()), SplitEffectsExpFat$class.this.projectS(x5.summary(), s), deps), reflect.this.Manifest.Unit(), reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 103)})))))
                    })
                  else
                    case8()
                }
              else
                case8()
            else
              case8()
          }
        else
          case8()
      };
      case8(){
        matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit())))
      };
      matchEnd6(x){
        x
      }
    };
    def projectSimpleS(u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Effects#Summary = {
      val qual$1: scala.virtualization.lms.internal.Effects#Summary = SplitEffectsExpFat$class.this.Pure();
      val x$17: Boolean = u.maySimple();
      val x$18: Boolean = u.mstSimple();
      val x$19: Boolean = qual$1.copy$default$3();
      val x$20: Boolean = qual$1.copy$default$4();
      val x$21: Boolean = qual$1.copy$default$5();
      val x$22: List = qual$1.copy$default$6();
      val x$23: List = qual$1.copy$default$7();
      val x$24: List = qual$1.copy$default$8();
      val x$25: List = qual$1.copy$default$9();
      qual$1.copy(x$17, x$18, x$19, x$20, x$21, x$22, x$23, x$24, x$25)
    };
    def projectSimpleB(b: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Blocks#Block = {
      case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
      case7(){
        if (x1.ne(null))
          {
            val o9: Option = SplitEffectsExpFat$class.this.Def().unapply(x1.res());
            if (o9.isEmpty().unary_!())
              if (o9.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                {
                  val x5: scala.virtualization.lms.internal.Effects#Reify = (o9.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                  if (x5.ne(null))
                    matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()), SplitEffectsExpFat$class.this.projectSimpleS(x5.summary()), SplitEffectsExpFat$class.this.calculateDependencies(x5.effects(), SplitEffectsExpFat$class.this.Simple())), reflect.this.Manifest.Unit(), reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 110)}))))))
                  else
                    case8()
                }
              else
                case8()
            else
              case8()
          }
        else
          case8()
      };
      case8(){
        matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit())))
      };
      matchEnd6(x){
        x
      }
    };
    def projectPureS(u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Effects#Summary = SplitEffectsExpFat$class.this.Pure();
    def projectPureB(b: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Blocks#Block = {
      case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
      case7(){
        if (x1.ne(null))
          {
            val o9: Option = SplitEffectsExpFat$class.this.Def().unapply(x1.res());
            if (o9.isEmpty().unary_!())
              if (o9.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                {
                  val x5: scala.virtualization.lms.internal.Effects#Reify = (o9.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                  if (x5.ne(null))
                    matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, x5.x()))
                  else
                    case8()
                }
              else
                case8()
            else
              case8()
          }
        else
          case8()
      };
      case8(){
        matchEnd6(b)
      };
      matchEnd6(x){
        x
      }
    };
    def projectPureWithB(b: scala.virtualization.lms.internal.Blocks#Block, s: List, evidence$2: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block = {
      case <synthetic> val x1: Tuple2 = new Tuple2(SplitEffectsExpFat$class.this.projectPureB(b), SplitEffectsExpFat$class.this.projectB(b, s));
      case14(){
        if (x1.ne(null))
          if (x1._1().ne(null))
            if (x1._2().ne(null))
              {
                val o16: Option = SplitEffectsExpFat$class.this.Def().unapply(x1._2().res());
                if (o16.isEmpty().unary_!())
                  if (o16.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                    {
                      val x8: scala.virtualization.lms.internal.Effects#Reify = (o16.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                      if (x8.ne(null))
                        if (x8.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#Const]())
                          {
                            val x10: scala.virtualization.lms.internal.Expressions#Const = (x8.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#Const](): scala.virtualization.lms.internal.Expressions#Const);
                            if (x10.ne(null))
                              if (().==(x10.x()))
                                {
                                  val x12: scala.runtime.BoxedUnit = x10.x();
                                  matchEnd13(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, x1._1().res(), x8.summary(), x8.effects()), evidence$2, reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 122)}))))))
                                }
                              else
                                case15()
                            else
                              case15()
                          }
                        else
                          case15()
                      else
                        case15()
                    }
                  else
                    case15()
                else
                  case15()
              }
            else
              case15()
          else
            case15()
        else
          case15()
      };
      case15(){
        if (x1.ne(null))
          matchEnd13(x1._1())
        else
          case17()
      };
      case17(){
        matchEnd13(throw new MatchError(x1))
      };
      matchEnd13(x){
        x
      }
    };
    def projectPureWithSimpleB(b: scala.virtualization.lms.internal.Blocks#Block, evidence$3: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block = {
      case <synthetic> val x1: Tuple2 = new Tuple2(SplitEffectsExpFat$class.this.projectPureB(b), SplitEffectsExpFat$class.this.projectSimpleB(b));
      case14(){
        if (x1.ne(null))
          if (x1._1().ne(null))
            if (x1._2().ne(null))
              {
                val o16: Option = SplitEffectsExpFat$class.this.Def().unapply(x1._2().res());
                if (o16.isEmpty().unary_!())
                  if (o16.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                    {
                      val x8: scala.virtualization.lms.internal.Effects#Reify = (o16.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                      if (x8.ne(null))
                        if (x8.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#Const]())
                          {
                            val x10: scala.virtualization.lms.internal.Expressions#Const = (x8.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#Const](): scala.virtualization.lms.internal.Expressions#Const);
                            if (x10.ne(null))
                              if (().==(x10.x()))
                                {
                                  val x12: scala.runtime.BoxedUnit = x10.x();
                                  matchEnd13(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, x1._1().res(), x8.summary(), x8.effects()), evidence$3, reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 128)}))))))
                                }
                              else
                                case15()
                            else
                              case15()
                          }
                        else
                          case15()
                      else
                        case15()
                    }
                  else
                    case15()
                else
                  case15()
              }
            else
              case15()
          else
            case15()
        else
          case15()
      };
      case15(){
        if (x1.ne(null))
          matchEnd13(x1._1())
        else
          case17()
      };
      case17(){
        matchEnd13(throw new MatchError(x1))
      };
      matchEnd13(x){
        x
      }
    };
    @volatile <synthetic> var scala$virtualization$lms$common$SplitEffectsExpFat$$SimpleFatWhile$module: ... = _;
    <synthetic> <stable> def SimpleFatWhile(): ... = new ...(SplitEffectsExpFat$class.this);
    override def syms(e: Object): List = {
      case <synthetic> val x1: Object = e;
      case4(){
        if (x1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().&&((x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile).scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer().eq(SplitEffectsExpFat$class.this)))
          {
            val x2: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
            if (x2.ne(null))
              matchEnd3(SplitEffectsExpFat$class.this.syms(x2.cond()).++(SplitEffectsExpFat$class.this.syms(x2.body()), immutable.this.List.canBuildFrom()).++(SplitEffectsExpFat$class.this.syms(x2.extradeps()), immutable.this.List.canBuildFrom()))
            else
              case5()
          }
        else
          case5()
      };
      case5(){
        matchEnd3(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$syms(e))
      };
      matchEnd3(x){
        x
      }
    };
    override def boundSyms(e: Object): List = {
      case <synthetic> val x1: Object = e;
      case4(){
        if (x1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().&&((x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile).scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer().eq(SplitEffectsExpFat$class.this)))
          {
            val x2: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
            if (x2.ne(null))
              matchEnd3({
                <synthetic> val x$3: List = SplitEffectsExpFat$class.this.effectSyms(x2.cond());
                SplitEffectsExpFat$class.this.effectSyms(x2.body()).:::(x$3)
              })
            else
              case5()
          }
        else
          case5()
      };
      case5(){
        matchEnd3(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$boundSyms(e))
      };
      matchEnd3(x){
        x
      }
    };
    override def symsFreq(e: Object): List = {
      case <synthetic> val x1: Object = e;
      case4(){
        if (x1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().&&((x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile).scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer().eq(SplitEffectsExpFat$class.this)))
          {
            val x2: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
            if (x2.ne(null))
              matchEnd3(SplitEffectsExpFat$class.this.freqHot(x2.cond()).++(SplitEffectsExpFat$class.this.freqHot(x2.body()), immutable.this.List.canBuildFrom()).++(SplitEffectsExpFat$class.this.freqNormal(x2.extradeps()), immutable.this.List.canBuildFrom()))
            else
              case5()
          }
        else
          case5()
      };
      case5(){
        matchEnd3(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$symsFreq(e))
      };
      matchEnd3(x){
        x
      }
    }
  };
  abstract trait PreviousIterationDummyExp$class extends Object with scala.virtualization.lms.common.BaseFatExp with scala.virtualization.lms.common.EffectExp$class with scala.virtualization.lms.common.PreviousIterationDummyExp {
    def /*PreviousIterationDummyExp$class*/$init$(): Unit = {
      ()
    };
    @volatile <synthetic> var scala$virtualization$lms$common$PreviousIterationDummyExp$$PreviousIteration$module: ... = _;
    <synthetic> <stable> def PreviousIteration(): ... = new ...(PreviousIterationDummyExp$class.this);
    @volatile <synthetic> var scala$virtualization$lms$common$PreviousIterationDummyExp$$SimpleFatPrevious$module: ... = _;
    <synthetic> <stable> def SimpleFatPrevious(): ... = new ...(PreviousIterationDummyExp$class.this);
    def reflectPreviousDummy(k: scala.virtualization.lms.internal.Expressions#Exp, u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Expressions#Exp = PreviousIterationDummyExp$class.this.reflectEffect(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration(PreviousIterationDummyExp$class.this, k), u, reflect.this.Manifest.Unit(), reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffect", "PreviousIterationDummyExp", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 164)}))))
  };
  abstract trait BaseGenSplitEffects$class extends Object with scala.virtualization.lms.common.BaseGenIfThenElseFat$class with scala.virtualization.lms.internal.GenericFatCodegen$class with scala.virtualization.lms.common.BaseGenSplitEffects {
    def /*BaseGenSplitEffects$class*/$init$(): Unit = {
      ()
    };
    override def reifyBlock(x: Function0, evidence$4: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block = {
      val sup: scala.virtualization.lms.internal.Blocks#Block = BaseGenSplitEffects$class.this.scala$virtualization$lms$common$BaseGenSplitEffects$$super$reifyBlock(x, evidence$4);
      BaseGenSplitEffects$class.this.IR().projectPureWithSimpleB(sup, evidence$4)
    };
    override def fatten(e: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
      var rc12: Boolean = false;
      var x2: scala.virtualization.lms.internal.Expressions#TP = (null: scala.virtualization.lms.internal.Expressions#TP);
      var rc13: Boolean = false;
      var x6: scala.virtualization.lms.internal.Effects#Reflect = (null: scala.virtualization.lms.internal.Effects#Reflect);
      {
        case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = e;
        case15(){
          if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
            {
              rc12 = true;
              x2 = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
              if (x2.ne(null))
                if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                  {
                    val x3: scala.virtualization.lms.common.WhileExp#While = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                    if (x3.ne(null))
                      matchEnd14(new scala.virtualization.lms.internal.FatExpressions#TTP(BaseGenSplitEffects$class.this.IR, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{x2.sym()})), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.common.WhileExp#While]{x3})), new scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile(BaseGenSplitEffects$class.this.IR, x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Blocks#Block]{x3.body()})))))
                    else
                      case16()
                  }
                else
                  case16()
              else
                case16()
            }
          else
            case16()
        };
        case16(){
          if (rc12)
            if (x2.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
              {
                rc13 = true;
                x6 = (x2.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                if (x6.ne(null))
                  if (x6.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                    {
                      val x7: scala.virtualization.lms.common.WhileExp#While = (x6.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                      if (x7.ne(null))
                        matchEnd14({
                          val x: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = new scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile(BaseGenSplitEffects$class.this.IR, x7.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Blocks#Block]{x7.body()})));
                          x.extradeps_=(x6.deps().asInstanceOf[List]());
                          new scala.virtualization.lms.internal.FatExpressions#TTP(BaseGenSplitEffects$class.this.IR, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{x2.sym()})), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Effects#Reflect]{x6})), x)
                        })
                      else
                        case17()
                    }
                  else
                    case17()
                else
                  case17()
              }
            else
              case17()
          else
            case17()
        };
        case17(){
          if (rc13)
            if (x6.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
              {
                val x11: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x6.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                if (x11.ne(null))
                  matchEnd14({
                    val x: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = new scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious(BaseGenSplitEffects$class.this.IR, x11.k(), x6.deps().asInstanceOf[List]());
                    new scala.virtualization.lms.internal.FatExpressions#TTP(BaseGenSplitEffects$class.this.IR, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{x2.sym()})), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Effects#Reflect]{x6})), x)
                  })
                else
                  case18()
              }
            else
              case18()
          else
            case18()
        };
        case18(){
          matchEnd14(BaseGenSplitEffects$class.this.scala$virtualization$lms$common$BaseGenSplitEffects$$super$fatten(e))
        };
        matchEnd14(x){
          x
        }
      }
    };
    override def fattenAll(e: List): List = {
      val e1: List = BaseGenSplitEffects$class.this.scala$virtualization$lms$common$BaseGenSplitEffects$$super$fattenAll(e);
      val e2: List = e1.collect({
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
          def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final override def applyOrElse(x$1: scala.virtualization.lms.internal.Expressions#Stm, default: Function1): Object = {
            var rc8: Boolean = false;
            var x2: scala.virtualization.lms.internal.FatExpressions#TTP = (null: scala.virtualization.lms.internal.FatExpressions#TTP);
            {
              case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x$1;
              case10(){
                if (x1.isInstanceOf[scala.virtualization.lms.internal.FatExpressions#TTP]())
                  {
                    rc8 = true;
                    x2 = (x1.asInstanceOf[scala.virtualization.lms.internal.FatExpressions#TTP](): scala.virtualization.lms.internal.FatExpressions#TTP);
                    if (x2.ne(null))
                      if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse]())
                        {
                          val x3: scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse](): scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse);
                          if (x3.ne(null))
                            matchEnd9(((x2: Object): Object))
                          else
                            case11()
                        }
                      else
                        case11()
                    else
                      case11()
                  }
                else
                  case11()
              };
              case11(){
                if (rc8)
                  if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]())
                    {
                      val x5: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
                      if (x5.ne(null))
                        matchEnd9(((x2: Object): Object))
                      else
                        case12()
                    }
                  else
                    case12()
                else
                  case12()
              };
              case12(){
                if (rc8)
                  if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]())
                    {
                      val x7: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious](): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious);
                      if (x7.ne(null))
                        matchEnd9(((x2: Object): Object))
                      else
                        case13()
                    }
                  else
                    case13()
                else
                  case13()
              };
              case13(){
                matchEnd9(default.apply(x$1))
              };
              matchEnd9(x){
                x
              }
            }
          };
          final def isDefinedAt(x$1: scala.virtualization.lms.internal.Expressions#Stm): Boolean = {
            var rc8: Boolean = false;
            var x2: scala.virtualization.lms.internal.FatExpressions#TTP = (null: scala.virtualization.lms.internal.FatExpressions#TTP);
            {
              case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x$1;
              case10(){
                if (x1.isInstanceOf[scala.virtualization.lms.internal.FatExpressions#TTP]())
                  {
                    rc8 = true;
                    x2 = (x1.asInstanceOf[scala.virtualization.lms.internal.FatExpressions#TTP](): scala.virtualization.lms.internal.FatExpressions#TTP);
                    if (x2.ne(null))
                      if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse]())
                        {
                          val x3: scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse](): scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse);
                          if (x3.ne(null))
                            matchEnd9(true)
                          else
                            case11()
                        }
                      else
                        case11()
                    else
                      case11()
                  }
                else
                  case11()
              };
              case11(){
                if (rc8)
                  if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]())
                    {
                      val x5: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
                      if (x5.ne(null))
                        matchEnd9(true)
                      else
                        case12()
                    }
                  else
                    case12()
                else
                  case12()
              };
              case12(){
                if (rc8)
                  if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]())
                    {
                      val x7: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious](): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious);
                      if (x7.ne(null))
                        matchEnd9(true)
                      else
                        case13()
                    }
                  else
                    case13()
                else
                  case13()
              };
              case13(){
                matchEnd9(false)
              };
              matchEnd9(x){
                x
              }
            }
          };
          <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
          <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
          final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
          final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
        };
        new anonymous class $anonfun(BaseGenSplitEffects$class.this)
      }, immutable.this.List.canBuildFrom());
      val m: scala.collection.immutable.Map = e2.groupBy({
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
          def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final def apply(x$1: scala.virtualization.lms.internal.FatExpressions#TTP): Tuple2 = {
            case <synthetic> val x1: scala.virtualization.lms.internal.FatExpressions#TTP = x$1;
            case13(){
              if (x1.ne(null))
                if (x1.rhs().isInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse]())
                  {
                    val x2: scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse = (x1.rhs().asInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse](): scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse);
                    if (x2.ne(null))
                      matchEnd12(new Tuple2(x2.cond(), "if"))
                    else
                      case14()
                  }
                else
                  case14()
              else
                case14()
            };
            case14(){
              if (x1.ne(null))
                if (x1.rhs().isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]())
                  {
                    val x4: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
                    if (x4.ne(null))
                      if (x4.cond().ne(null))
                        {
                          val o16: Option = $anonfun.this.$outer.IR().Def().unapply(x4.cond().res());
                          if (o16.isEmpty().unary_!())
                            if (o16.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                              {
                                val x10: scala.virtualization.lms.internal.Effects#Reify = (o16.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                                if (x10.ne(null))
                                  matchEnd12(new Tuple2(x10.x(), "while"))
                                else
                                  case15()
                              }
                            else
                              case15()
                          else
                            case15()
                        }
                      else
                        case15()
                    else
                      case15()
                  }
                else
                  case15()
              else
                case15()
            };
            case15(){
              if (x1.ne(null))
                if (x1.rhs().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]())
                  {
                    val x11: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = (x1.rhs().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious](): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious);
                    if (x11.ne(null))
                      matchEnd12(new Tuple2(x11.k(), "prev"))
                    else
                      case17()
                  }
                else
                  case17()
              else
                case17()
            };
            case17(){
              matchEnd12(throw new MatchError(x1))
            };
            matchEnd12(x){
              x
            }
          };
          <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
          <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
          final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
        };
        new anonymous class $anonfun(BaseGenSplitEffects$class.this)
      });
      val e3: List = e1.diff(e2);
      val g1: scala.collection.immutable.Iterable = m.map({
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
          def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final def apply(x$1: Tuple2): scala.virtualization.lms.internal.FatExpressions#TTP = {
            case <synthetic> val x1: Tuple2 = x$1;
            case17(){
              if (x1.ne(null))
                if (x1._1().ne(null))
                  if (x1._1()._1().ne(null))
                    {
                      val x8: scala.virtualization.lms.internal.Expressions#Exp = x1._1()._1();
                      if ("if".==(x1._1()._2()))
                        {
                          val x9: String = x1._1()._2();
                          if (x1._2().ne(null))
                            {
                              val x10: List = x1._2();
                              matchEnd16(new scala.virtualization.lms.internal.FatExpressions#TTP($anonfun.this.$outer.IR, x10.flatMap({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final def apply(x$4: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$4.lhs();
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                };
                                (new anonymous class $anonfun($anonfun.this): Function1)
                              }, immutable.this.List.canBuildFrom()), x10.flatMap({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final def apply(x$5: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$5.mhs();
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                };
                                (new anonymous class $anonfun($anonfun.this): Function1)
                              }, immutable.this.List.canBuildFrom()), new scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse($anonfun.this.$outer.IR, x8, x10.flatMap({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final def apply(x$6: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$6.rhs().asInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse]().thenp();
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                };
                                (new anonymous class $anonfun($anonfun.this): Function1)
                              }, immutable.this.List.canBuildFrom()), x10.flatMap({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final def apply(x$7: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$7.rhs().asInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse]().elsep();
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                };
                                (new anonymous class $anonfun($anonfun.this): Function1)
                              }, immutable.this.List.canBuildFrom()))))
                            }
                          else
                            case18()
                        }
                      else
                        case18()
                    }
                  else
                    case18()
                else
                  case18()
              else
                case18()
            };
            case18(){
              if (x1.ne(null))
                if (x1._1().ne(null))
                  if ("while".==(x1._1()._2()))
                    {
                      val x11: String = x1._1()._2();
                      if (x1._2().ne(null))
                        {
                          val x12: List = x1._2();
                          matchEnd16({
                            val x: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = new scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile($anonfun.this.$outer.IR, x12.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(x$8: scala.virtualization.lms.internal.FatExpressions#TTP): scala.virtualization.lms.internal.Blocks#Block = x$8.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().cond();
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).apply(0), x12.flatMap({
                              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                  $anonfun.super.<init>();
                                  ()
                                };
                                final def apply(x$9: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$9.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().body();
                                <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                              };
                              (new anonymous class $anonfun($anonfun.this): Function1)
                            }, immutable.this.List.canBuildFrom()));
                            x.extradeps_=(x12.flatMap({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(x$10: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$10.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().extradeps();
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).diff(x12.flatMap({
                              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                  $anonfun.super.<init>();
                                  ()
                                };
                                final def apply(x$11: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$11.lhs();
                                <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                              };
                              (new anonymous class $anonfun($anonfun.this): Function1)
                            }, immutable.this.List.canBuildFrom())));
                            new scala.virtualization.lms.internal.FatExpressions#TTP($anonfun.this.$outer.IR, x12.flatMap({
                              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                  $anonfun.super.<init>();
                                  ()
                                };
                                final def apply(x$12: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$12.lhs();
                                <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                              };
                              (new anonymous class $anonfun($anonfun.this): Function1)
                            }, immutable.this.List.canBuildFrom()), x12.flatMap({
                              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                  $anonfun.super.<init>();
                                  ()
                                };
                                final def apply(x$13: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$13.mhs();
                                <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                              };
                              (new anonymous class $anonfun($anonfun.this): Function1)
                            }, immutable.this.List.canBuildFrom()), x)
                          })
                        }
                      else
                        case19()
                    }
                  else
                    case19()
                else
                  case19()
              else
                case19()
            };
            case19(){
              if (x1.ne(null))
                if (x1._1().ne(null))
                  if (x1._1()._1().isInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]())
                    {
                      val x13: scala.virtualization.lms.internal.Expressions#Exp = (x1._1()._1().asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp](): scala.virtualization.lms.internal.Expressions#Exp);
                      if ("prev".==(x1._1()._2()))
                        {
                          val x14: String = x1._1()._2();
                          if (x1._2().ne(null))
                            {
                              val x15: List = x1._2();
                              matchEnd16(new scala.virtualization.lms.internal.FatExpressions#TTP($anonfun.this.$outer.IR, x15.flatMap({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final def apply(x$14: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$14.lhs();
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                };
                                (new anonymous class $anonfun($anonfun.this): Function1)
                              }, immutable.this.List.canBuildFrom()), x15.flatMap({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final def apply(x$15: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$15.mhs();
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                };
                                (new anonymous class $anonfun($anonfun.this): Function1)
                              }, immutable.this.List.canBuildFrom()), new scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious($anonfun.this.$outer.IR, x13, x15.flatMap({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final def apply(x$16: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$16.rhs().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]().extra();
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                };
                                (new anonymous class $anonfun($anonfun.this): Function1)
                              }, immutable.this.List.canBuildFrom()))))
                            }
                          else
                            case20()
                        }
                      else
                        case20()
                    }
                  else
                    case20()
                else
                  case20()
              else
                case20()
            };
            case20(){
              matchEnd16(throw new MatchError(x1))
            };
            matchEnd16(x){
              x
            }
          };
          <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
          <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
          final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
        };
        new anonymous class $anonfun(BaseGenSplitEffects$class.this)
      }, immutable.this.Iterable.canBuildFrom());
      val r: List = e3.++(g1, immutable.this.List.canBuildFrom());
      r
    };
    override def emitFatNode(symList: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit = {
      case <synthetic> val x1: scala.virtualization.lms.internal.FatExpressions#FatDef = rhs;
      case4(){
        if (x1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]())
          {
            val x2: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
            if (x2.ne(null))
              matchEnd3({
                def quoteList(xs: List): String = BaseGenSplitEffects$class.this.IR().__ifThenElse({
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                    <specialized> def apply$mcZ$sp(): Boolean = xs.length().>(1);
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(BaseGenSplitEffects$class.this): Function0)
                }, {
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): String = xs.map({
  {
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(x: scala.virtualization.lms.internal.Expressions#Exp): String = $anonfun.this.$outer.scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer().quote(x);
      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
      <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
    };
    (new anonymous class $anonfun($anonfun.this): Function1)
  }
}, immutable.this.List.canBuildFrom()).mkString("(", ",", ")");
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(BaseGenSplitEffects$class.this): Function0)
                }, {
                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                    def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
                      $anonfun.super.<init>();
                      ()
                    };
                    final def apply(): String = xs.map({
  {
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(x: scala.virtualization.lms.internal.Expressions#Exp): String = $anonfun.this.$outer.scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer().quote(x);
      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
      <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
    };
    (new anonymous class $anonfun($anonfun.this): Function1)
  }
}, immutable.this.List.canBuildFrom()).mkString(",");
                    <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
                    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
                    final <bridge> def apply(): Object = $anonfun.this.apply()
                  };
                  (new anonymous class $anonfun(BaseGenSplitEffects$class.this): Function0)
                });
                BaseGenSplitEffects$class.this.stream().println("while ({ // ".+(symList));
                BaseGenSplitEffects$class.this.emitFatBlock(immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Blocks#Block]{x2.cond()})));
                BaseGenSplitEffects$class.this.stream().println(quoteList(immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Blocks#Block]{x2.cond()})).map({
                  {
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(s: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.getBlockResult(s);
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
                      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                    };
                    (new anonymous class $anonfun(BaseGenSplitEffects$class.this): Function1)
                  }
                }, immutable.this.List.canBuildFrom())));
                BaseGenSplitEffects$class.this.stream().println("}) {");
                BaseGenSplitEffects$class.this.emitFatBlock(x2.body());
                BaseGenSplitEffects$class.this.stream().println("}")
              })
            else
              case5()
          }
        else
          case5()
      };
      case5(){
        matchEnd3(BaseGenSplitEffects$class.this.scala$virtualization$lms$common$BaseGenSplitEffects$$super$emitFatNode(symList, rhs))
      };
      matchEnd3(x){
        x
      }
    }
  };
  abstract trait ScalaGenPreviousIterationDummy$class extends Object with scala.virtualization.lms.common.ScalaGenFat with scala.virtualization.lms.common.ScalaGenPreviousIterationDummy {
    def /*ScalaGenPreviousIterationDummy$class*/$init$(): Unit = {
      ()
    };
    override def emitNode(sym: scala.virtualization.lms.internal.Expressions#Sym, rhs: scala.virtualization.lms.internal.Expressions#Def): Unit = {
      case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Def = rhs;
      case6(){
        if (x1.isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
          {
            val x3: scala.virtualization.lms.internal.Effects#Reflect = (x1.asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
            if (x3.ne(null))
              if (x3.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                {
                  val x4: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x3.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                  if (x4.ne(null))
                    matchEnd5(())
                  else
                    case7()
                }
              else
                case7()
            else
              case7()
          }
        else
          case7()
      };
      case7(){
        matchEnd5(ScalaGenPreviousIterationDummy$class.this.scala$virtualization$lms$common$ScalaGenPreviousIterationDummy$$super$emitNode(sym, rhs))
      };
      matchEnd5(x){
        x
      }
    };
    override def emitFatNode(symList: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit = {
      case <synthetic> val x1: scala.virtualization.lms.internal.FatExpressions#FatDef = rhs;
      case4(){
        if (x1.isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]())
          {
            val x2: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = (x1.asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious](): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious);
            if (x2.ne(null))
              matchEnd3(ScalaGenPreviousIterationDummy$class.this.stream().println("// dummy placeholder for previous iteration: ".+(symList).+(" = ").+(x2.k()).+(" / ").+(x2.extra())))
            else
              case5()
          }
        else
          case5()
      };
      case5(){
        matchEnd3(ScalaGenPreviousIterationDummy$class.this.scala$virtualization$lms$common$ScalaGenPreviousIterationDummy$$super$emitFatNode(symList, rhs))
      };
      matchEnd3(x){
        x
      }
    }
  }
}
exception when typing package scala.virtualization.lms {
  package common {
    abstract trait SplitEffectsExpFat extends Object with scala.virtualization.lms.common.IfThenElseFatExp with scala.virtualization.lms.common.WhileExp with scala.virtualization.lms.common.PreviousIterationDummyExp { `this`: scala.virtualization.lms.common.BooleanOpsExp => 
      final <superaccessor> def scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(x: scala.virtualization.lms.internal.Expressions#Def, u: scala.virtualization.lms.internal.Effects#Summary, evidence$7: scala.reflect.Manifest, pos: scala.reflect.SourceContext): scala.virtualization.lms.internal.Expressions#Exp;
      final <superaccessor> def scala$virtualization$lms$common$SplitEffectsExpFat$$super$syms(e: Object): List;
      final <superaccessor> def scala$virtualization$lms$common$SplitEffectsExpFat$$super$boundSyms(e: Object): List;
      final <superaccessor> def scala$virtualization$lms$common$SplitEffectsExpFat$$super$symsFreq(e: Object): List;
      override def reflectEffectInternal(x: scala.virtualization.lms.internal.Expressions#Def, u: scala.virtualization.lms.internal.Effects#Summary, evidence$1: scala.reflect.Manifest, pos: scala.reflect.SourceContext): scala.virtualization.lms.internal.Expressions#Exp;
      def projectL(a: List, s: List): List;
      def projectS(u: scala.virtualization.lms.internal.Effects#Summary, s: List): scala.virtualization.lms.internal.Effects#Summary;
      def projectB(b: scala.virtualization.lms.internal.Blocks#Block, s: List): scala.virtualization.lms.internal.Blocks#Block;
      def projectSimpleS(u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Effects#Summary;
      def projectSimpleB(b: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Blocks#Block;
      def projectPureS(u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Effects#Summary;
      def projectPureB(b: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Blocks#Block;
      def projectPureWithB(b: scala.virtualization.lms.internal.Blocks#Block, s: List, evidence$2: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block;
      def projectPureWithSimpleB(b: scala.virtualization.lms.internal.Blocks#Block, evidence$3: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block;
      case class SimpleFatWhile extends scala.virtualization.lms.internal.FatExpressions#FatDef with Product with Serializable {
        <caseaccessor> <paramaccessor> private[this] val cond: scala.virtualization.lms.internal.Blocks#Block = _;
        <stable> <caseaccessor> <accessor> <paramaccessor> def cond(): scala.virtualization.lms.internal.Blocks#Block = SimpleFatWhile.this.cond;
        <caseaccessor> <paramaccessor> private[this] val body: List = _;
        <stable> <caseaccessor> <accessor> <paramaccessor> def body(): List = SimpleFatWhile.this.body;
        def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp, cond: scala.virtualization.lms.internal.Blocks#Block, body: List): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = {
          SimpleFatWhile.super.<init>($outer);
          SimpleFatWhile.this./*Product$class*/$init$();
          ()
        };
        private[this] var extradeps: List = immutable.this.Nil;
        <accessor> def extradeps(): List = SimpleFatWhile.this.extradeps;
        <accessor> def extradeps_=(x$1: List): Unit = SimpleFatWhile.this.extradeps = x$1;
        <synthetic> def copy(cond: scala.virtualization.lms.internal.Blocks#Block = cond, body: List = body): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = new scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile(SimpleFatWhile.this.scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer(), cond, body);
        <synthetic> def copy$default$1(): scala.virtualization.lms.internal.Blocks#Block = SimpleFatWhile.this.cond();
        <synthetic> def copy$default$2(): List = SimpleFatWhile.this.body();
        override <synthetic> def productPrefix(): String = "SimpleFatWhile";
        <synthetic> def productArity(): Int = 2;
        <synthetic> def productElement(x$1: Int): Object = {
          case <synthetic> val x1: Int = x$1;
          (x1: Int) match {
            case 0 => SimpleFatWhile.this.cond()
            case 1 => SimpleFatWhile.this.body()
            case _ => throw new IndexOutOfBoundsException(x$1.toString())
          }
        };
        override <synthetic> def productIterator(): Iterator = runtime.this.ScalaRunTime.typedProductIterator(SimpleFatWhile.this);
        <synthetic> def canEqual(x$1: Object): Boolean = x$1.$isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]();
        <synthetic> def _1(): scala.virtualization.lms.internal.Blocks#Block = SimpleFatWhile.this.cond();
        <synthetic> def _2(): List = SimpleFatWhile.this.body();
        override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(SimpleFatWhile.this);
        override <synthetic> def toString(): String = ScalaRunTime.this._toString(SimpleFatWhile.this);
        override <synthetic> def equals(x$1: Object): Boolean = SimpleFatWhile.this.eq(x$1.asInstanceOf[Object]()).||(x$1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().&&({
          <synthetic> val SimpleFatWhile$1: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = x$1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]();
          SimpleFatWhile.this.cond().==(SimpleFatWhile$1.cond()).&&(SimpleFatWhile.this.body().==(SimpleFatWhile$1.body())).&&(SimpleFatWhile$1.canEqual(SimpleFatWhile.this))
        }));
        <synthetic> <paramaccessor> protected val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = SimpleFatWhile.this.$outer
      };
      <synthetic> object SimpleFatWhile extends scala.runtime.AbstractFunction2 with Serializable {
        def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): ... = {
          SimpleFatWhile.super.<init>();
          ()
        };
        final override def toString(): String = "SimpleFatWhile";
        case <synthetic> def apply(cond: scala.virtualization.lms.internal.Blocks#Block, body: List): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = new scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile(SimpleFatWhile.this.$outer, cond, body);
        case <synthetic> def unapply(x$0: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile): Option = if (x$0.==(null))
          scala.this.None
        else
          new Some(new Tuple2(x$0.cond(), x$0.body()));
        <synthetic> private def readResolve(): Object = SimpleFatWhile.this.$outer.SimpleFatWhile();
        <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
        <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = SimpleFatWhile.this.$outer;
        case <synthetic> <bridge> def apply(v1: Object, v2: Object): Object = SimpleFatWhile.this.apply(v1, v2)
      };
      <synthetic> <stable> def SimpleFatWhile(): ...;
      override def syms(e: Object): List;
      override def boundSyms(e: Object): List;
      override def symsFreq(e: Object): List
    };
    abstract trait PreviousIterationDummyExp extends Object with scala.virtualization.lms.common.BaseFatExp with scala.virtualization.lms.common.EffectExp {
      case class PreviousIteration extends scala.virtualization.lms.internal.Expressions#Def with Product with Serializable {
        <caseaccessor> <paramaccessor> private[this] val k: scala.virtualization.lms.internal.Expressions#Exp = _;
        <stable> <caseaccessor> <accessor> <paramaccessor> def k(): scala.virtualization.lms.internal.Expressions#Exp = PreviousIteration.this.k;
        def <init>($outer: scala.virtualization.lms.common.PreviousIterationDummyExp, k: scala.virtualization.lms.internal.Expressions#Exp): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = {
          PreviousIteration.super.<init>($outer);
          PreviousIteration.this./*Product$class*/$init$();
          ()
        };
        <synthetic> def copy(k: scala.virtualization.lms.internal.Expressions#Exp = k): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration(PreviousIteration.this.scala$virtualization$lms$common$PreviousIterationDummyExp$PreviousIteration$$$outer(), k);
        <synthetic> def copy$default$1(): scala.virtualization.lms.internal.Expressions#Exp = PreviousIteration.this.k();
        override <synthetic> def productPrefix(): String = "PreviousIteration";
        <synthetic> def productArity(): Int = 1;
        <synthetic> def productElement(x$1: Int): Object = {
          case <synthetic> val x1: Int = x$1;
          case4(){
            if (0.==(x1))
              {
                val x2: Int = x1;
                matchEnd3(PreviousIteration.this.k())
              }
            else
              case5()
          };
          case5(){
            matchEnd3(throw new IndexOutOfBoundsException(x$1.toString()))
          };
          matchEnd3(x: Object){
            x
          }
        };
        override <synthetic> def productIterator(): Iterator = runtime.this.ScalaRunTime.typedProductIterator(PreviousIteration.this);
        <synthetic> def canEqual(x$1: Object): Boolean = x$1.$isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]();
        <synthetic> def _1(): scala.virtualization.lms.internal.Expressions#Exp = PreviousIteration.this.k();
        override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(PreviousIteration.this);
        override <synthetic> def toString(): String = ScalaRunTime.this._toString(PreviousIteration.this);
        override <synthetic> def equals(x$1: Object): Boolean = PreviousIteration.this.eq(x$1.asInstanceOf[Object]()).||(x$1.isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]().&&({
          <synthetic> val PreviousIteration$1: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = x$1.asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]();
          PreviousIteration.this.k().==(PreviousIteration$1.k()).&&(PreviousIteration$1.canEqual(PreviousIteration.this))
        }));
        <synthetic> <paramaccessor> protected val $outer: scala.virtualization.lms.common.PreviousIterationDummyExp = _;
        <synthetic> <stable> def scala$virtualization$lms$common$PreviousIterationDummyExp$PreviousIteration$$$outer(): scala.virtualization.lms.common.PreviousIterationDummyExp = PreviousIteration.this.$outer
      };
      <synthetic> object PreviousIteration extends scala.runtime.AbstractFunction1 with Serializable {
        def <init>($outer: scala.virtualization.lms.common.PreviousIterationDummyExp): ... = {
          PreviousIteration.super.<init>();
          ()
        };
        final override def toString(): String = "PreviousIteration";
        case <synthetic> def apply(k: scala.virtualization.lms.internal.Expressions#Exp): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration(PreviousIteration.this.$outer, k);
        case <synthetic> def unapply(x$0: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration): Option = if (x$0.==(null))
          scala.this.None
        else
          new Some(x$0.k());
        <synthetic> private def readResolve(): Object = PreviousIteration.this.$outer.PreviousIteration();
        <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.PreviousIterationDummyExp = _;
        <synthetic> <stable> def scala$virtualization$lms$common$PreviousIterationDummyExp$PreviousIteration$$$outer(): scala.virtualization.lms.common.PreviousIterationDummyExp = PreviousIteration.this.$outer;
        case <synthetic> <bridge> def apply(v1: Object): Object = PreviousIteration.this.apply(v1)
      };
      <synthetic> <stable> def PreviousIteration(): ...;
      case class SimpleFatPrevious extends scala.virtualization.lms.internal.FatExpressions#FatDef with Product with Serializable {
        <caseaccessor> <paramaccessor> private[this] val k: scala.virtualization.lms.internal.Expressions#Exp = _;
        <stable> <caseaccessor> <accessor> <paramaccessor> def k(): scala.virtualization.lms.internal.Expressions#Exp = SimpleFatPrevious.this.k;
        <caseaccessor> <paramaccessor> private[this] val extra: List = _;
        <stable> <caseaccessor> <accessor> <paramaccessor> def extra(): List = SimpleFatPrevious.this.extra;
        def <init>($outer: scala.virtualization.lms.common.PreviousIterationDummyExp, k: scala.virtualization.lms.internal.Expressions#Exp, extra: List): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = {
          SimpleFatPrevious.super.<init>($outer);
          SimpleFatPrevious.this./*Product$class*/$init$();
          ()
        };
        <synthetic> def copy(k: scala.virtualization.lms.internal.Expressions#Exp = k, extra: List = extra): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = new scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious(SimpleFatPrevious.this.scala$virtualization$lms$common$PreviousIterationDummyExp$SimpleFatPrevious$$$outer(), k, extra);
        <synthetic> def copy$default$1(): scala.virtualization.lms.internal.Expressions#Exp = SimpleFatPrevious.this.k();
        <synthetic> def copy$default$2(): List = SimpleFatPrevious.this.extra();
        override <synthetic> def productPrefix(): String = "SimpleFatPrevious";
        <synthetic> def productArity(): Int = 2;
        <synthetic> def productElement(x$1: Int): Object = {
          case <synthetic> val x1: Int = x$1;
          (x1: Int) match {
            case 0 => SimpleFatPrevious.this.k()
            case 1 => SimpleFatPrevious.this.extra()
            case _ => throw new IndexOutOfBoundsException(x$1.toString())
          }
        };
        override <synthetic> def productIterator(): Iterator = runtime.this.ScalaRunTime.typedProductIterator(SimpleFatPrevious.this);
        <synthetic> def canEqual(x$1: Object): Boolean = x$1.$isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]();
        <synthetic> def _1(): scala.virtualization.lms.internal.Expressions#Exp = SimpleFatPrevious.this.k();
        <synthetic> def _2(): List = SimpleFatPrevious.this.extra();
        override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(SimpleFatPrevious.this);
        override <synthetic> def toString(): String = ScalaRunTime.this._toString(SimpleFatPrevious.this);
        override <synthetic> def equals(x$1: Object): Boolean = SimpleFatPrevious.this.eq(x$1.asInstanceOf[Object]()).||(x$1.isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]().&&({
          <synthetic> val SimpleFatPrevious$1: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = x$1.asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]();
          SimpleFatPrevious.this.k().==(SimpleFatPrevious$1.k()).&&(SimpleFatPrevious.this.extra().==(SimpleFatPrevious$1.extra())).&&(SimpleFatPrevious$1.canEqual(SimpleFatPrevious.this))
        }));
        <synthetic> <paramaccessor> protected val $outer: scala.virtualization.lms.common.PreviousIterationDummyExp = _;
        <synthetic> <stable> def scala$virtualization$lms$common$PreviousIterationDummyExp$SimpleFatPrevious$$$outer(): scala.virtualization.lms.common.PreviousIterationDummyExp = SimpleFatPrevious.this.$outer
      };
      <synthetic> object SimpleFatPrevious extends scala.runtime.AbstractFunction2 with Serializable {
        def <init>($outer: scala.virtualization.lms.common.PreviousIterationDummyExp): ... = {
          SimpleFatPrevious.super.<init>();
          ()
        };
        final override def toString(): String = "SimpleFatPrevious";
        case <synthetic> def apply(k: scala.virtualization.lms.internal.Expressions#Exp, extra: List): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = new scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious(SimpleFatPrevious.this.$outer, k, extra);
        case <synthetic> def unapply(x$0: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious): Option = if (x$0.==(null))
          scala.this.None
        else
          new Some(new Tuple2(x$0.k(), x$0.extra()));
        <synthetic> private def readResolve(): Object = SimpleFatPrevious.this.$outer.SimpleFatPrevious();
        <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.PreviousIterationDummyExp = _;
        <synthetic> <stable> def scala$virtualization$lms$common$PreviousIterationDummyExp$SimpleFatPrevious$$$outer(): scala.virtualization.lms.common.PreviousIterationDummyExp = SimpleFatPrevious.this.$outer;
        case <synthetic> <bridge> def apply(v1: Object, v2: Object): Object = SimpleFatPrevious.this.apply(v1, v2)
      };
      <synthetic> <stable> def SimpleFatPrevious(): ...;
      def reflectPreviousDummy(k: scala.virtualization.lms.internal.Expressions#Exp, u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Expressions#Exp
    };
    abstract trait BaseGenSplitEffects extends Object with scala.virtualization.lms.common.BaseGenIfThenElseFat with scala.virtualization.lms.internal.GenericFatCodegen {
      final <superaccessor> def scala$virtualization$lms$common$BaseGenSplitEffects$$super$reifyBlock(x: Function0, evidence$2: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block;
      final <superaccessor> def scala$virtualization$lms$common$BaseGenSplitEffects$$super$fatten(e: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm;
      final <superaccessor> def scala$virtualization$lms$common$BaseGenSplitEffects$$super$fattenAll(e: List): List;
      final <superaccessor> def scala$virtualization$lms$common$BaseGenSplitEffects$$super$emitFatNode(sym: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit;
      <stable> <accessor> def IR(): scala.virtualization.lms.common.SplitEffectsExpFat;
      override def reifyBlock(x: Function0, evidence$4: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block;
      override def fatten(e: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm;
      override def fattenAll(e: List): List;
      override def emitFatNode(symList: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit
    };
    abstract trait ScalaGenSplitEffects extends Object with scala.virtualization.lms.common.BaseGenSplitEffects with scala.virtualization.lms.common.ScalaGenIfThenElseFat {
      <stable> <accessor> def IR(): scala.virtualization.lms.common.SplitEffectsExpFat
    };
    abstract trait ScalaGenPreviousIterationDummy extends Object with scala.virtualization.lms.common.ScalaGenFat {
      final <superaccessor> def scala$virtualization$lms$common$ScalaGenPreviousIterationDummy$$super$emitNode(sym: scala.virtualization.lms.internal.Expressions#Sym, rhs: scala.virtualization.lms.internal.Expressions#Def): Unit;
      final <superaccessor> def scala$virtualization$lms$common$ScalaGenPreviousIterationDummy$$super$emitFatNode(sym: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit;
      <stable> <accessor> def IR(): scala.virtualization.lms.common.PreviousIterationDummyExp;
      override def emitNode(sym: scala.virtualization.lms.internal.Expressions#Sym, rhs: scala.virtualization.lms.internal.Expressions#Def): Unit;
      override def emitFatNode(symList: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit
    };
    abstract trait SplitEffectsExpFat$class extends Object with scala.virtualization.lms.common.IfThenElseFatExp$class with scala.virtualization.lms.common.WhileExp$class with scala.virtualization.lms.common.PreviousIterationDummyExp$class with scala.virtualization.lms.common.SplitEffectsExpFat { `this`: scala.virtualization.lms.common.BooleanOpsExp => 
      def /*SplitEffectsExpFat$class*/$init$(): Unit = {
        ()
      };
      override def reflectEffectInternal(x: scala.virtualization.lms.internal.Expressions#Def, u: scala.virtualization.lms.internal.Effects#Summary, evidence$1: scala.reflect.Manifest, pos: scala.reflect.SourceContext): scala.virtualization.lms.internal.Expressions#Exp = {
        case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Def = x;
        case6(){
          if (x1.isInstanceOf[scala.virtualization.lms.common.IfThenElseExp#IfThenElse]())
            {
              val x2: scala.virtualization.lms.common.IfThenElseExp#IfThenElse = (x1.asInstanceOf[scala.virtualization.lms.common.IfThenElseExp#IfThenElse](): scala.virtualization.lms.common.IfThenElseExp#IfThenElse);
              if (x2.ne(null))
                matchEnd5({
                  val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
                  affected.foreach({
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse($anonfun.this.$outer, x2.cond(), $anonfun.this.$outer.projectB(x2.thenp(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), $anonfun.this.$outer.projectB(x2.elsep(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit()), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 26)})))));
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
                  });
                  SplitEffectsExpFat$class.this.__ifThenElse({
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                      <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                  }, {
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse($anonfun.this.$outer, x2.cond(), $anonfun.this.$outer.projectSimpleB(x2.thenp()), $anonfun.this.$outer.projectSimpleB(x2.elsep()), reflect.this.Manifest.Unit()), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 29)})))));
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                  }, {
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                      <specialized> def apply$mcV$sp(): Unit = ();
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                  });
                  SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.IfThenElseExp#IfThenElse(SplitEffectsExpFat$class.this, x2.cond(), SplitEffectsExpFat$class.this.projectPureB(x2.thenp()), SplitEffectsExpFat$class.this.projectPureB(x2.elsep()), evidence$1), SplitEffectsExpFat$class.this.projectPureS(u), evidence$1, pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 31)})))))
                })
              else
                case7()
            }
          else
            case7()
        };
        case7(){
          if (x1.isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
            {
              val x3: scala.virtualization.lms.common.WhileExp#While = (x1.asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
              if (x3.ne(null))
                matchEnd5({
                  val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
                  affected.foreach({
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcVL$sp with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): Unit = {
                        val cc: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Boolean());
                        val bb: scala.virtualization.lms.internal.Blocks#Block = $anonfun.this.$outer.projectPureWithB(x3.body(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s})), reflect.this.Manifest.Unit());
                        $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, cc, bb), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 40)})))));
                        val loopSym: scala.virtualization.lms.internal.Expressions#Sym = {
                          case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = ($anonfun.this.$outer.globalDefs().last(): scala.virtualization.lms.internal.Expressions#Stm);
                          case12(){
                            if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                              {
                                val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                if (x3.ne(null))
                                  if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                    {
                                      val x7: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                      if (x7.ne(null))
                                        if (x7.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                                          {
                                            val x10: scala.virtualization.lms.common.WhileExp#While = (x7.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                                            if (x10.ne(null))
                                              matchEnd11(x3.sym())
                                            else
                                              case13()
                                          }
                                        else
                                          case13()
                                      else
                                        case13()
                                    }
                                  else
                                    case13()
                                else
                                  case13()
                              }
                            else
                              case13()
                          };
                          case13(){
                            matchEnd11(throw new MatchError(x1))
                          };
                          matchEnd11(x: scala.virtualization.lms.internal.Expressions#Sym){
                            x
                          }
                        };
                        def xtract(b: scala.virtualization.lms.internal.Blocks#Block): List = {
                          case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
                          case10(){
                            if (x1.ne(null))
                              {
                                val o12: Option = $anonfun.this.$outer.Def().unapply(x1.res());
                                if (o12.isEmpty().unary_!())
                                  if (o12.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                                    {
                                      val x7: scala.virtualization.lms.internal.Effects#Reify = (o12.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                                      if (x7.ne(null))
                                        if (x7.effects().isInstanceOf[List]())
                                          {
                                            val x8: List = (x7.effects().asInstanceOf[List](): List);
                                            matchEnd9(x8.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(e: scala.virtualization.lms.internal.Expressions#Sym): Option = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().findDefinition(e);
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).collect({
                                              @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
                                                def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                                  $anonfun.super.<init>();
                                                  ()
                                                };
                                                final override def applyOrElse(x$1: Option, default: Function1): Object = {
                                                  case <synthetic> val x1: Option = x$1;
                                                  case11(){
                                                    if (x1.isInstanceOf[Some]())
                                                      {
                                                        val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                        if (x2.ne(null))
                                                          if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                            {
                                                              val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                              if (x4.ne(null))
                                                                if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                                  {
                                                                    val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                                    if (x7.ne(null))
                                                                      if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                        {
                                                                          val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                          if (x9.ne(null))
                                                                            if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                              matchEnd10(x4)
                                                                            else
                                                                              case12()
                                                                          else
                                                                            case12()
                                                                        }
                                                                      else
                                                                        case12()
                                                                    else
                                                                      case12()
                                                                  }
                                                                else
                                                                  case12()
                                                              else
                                                                case12()
                                                            }
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  };
                                                  case12(){
                                                    matchEnd10(default.apply(x$1))
                                                  };
                                                  matchEnd10(x: Object){
                                                    x
                                                  }
                                                };
                                                final def isDefinedAt(x$1: Option): Boolean = {
                                                  case <synthetic> val x1: Option = x$1;
                                                  case11(){
                                                    if (x1.isInstanceOf[Some]())
                                                      {
                                                        val x2: Some = (x1.asInstanceOf[Some](): Some);
                                                        if (x2.ne(null))
                                                          if (x2.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                                                            {
                                                              val x4: scala.virtualization.lms.internal.Expressions#TP = (x2.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                                              if (x4.ne(null))
                                                                if (x4.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                                                  {
                                                                    val x7: scala.virtualization.lms.internal.Effects#Reflect = (x4.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                                                    if (x7.ne(null))
                                                                      if (x7.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                                                        {
                                                                          val x9: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x7.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                                                          if (x9.ne(null))
                                                                            if ($anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer().mayWrite(x7.summary(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))))
                                                                              matchEnd10(true)
                                                                            else
                                                                              case12()
                                                                          else
                                                                            case12()
                                                                        }
                                                                      else
                                                                        case12()
                                                                    else
                                                                      case12()
                                                                  }
                                                                else
                                                                  case12()
                                                              else
                                                                case12()
                                                            }
                                                          else
                                                            case12()
                                                        else
                                                          case12()
                                                      }
                                                    else
                                                      case12()
                                                  };
                                                  case12(){
                                                    matchEnd10(false)
                                                  };
                                                  matchEnd10(x: Boolean){
                                                    x
                                                  }
                                                };
                                                <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                                <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                                final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
                                                final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
                                              };
                                              new anonymous class $anonfun($anonfun.this)
                                            }, immutable.this.List.canBuildFrom()))
                                          }
                                        else
                                          case11()
                                      else
                                        case11()
                                    }
                                  else
                                    case11()
                                else
                                  case11()
                              }
                            else
                              case11()
                          };
                          case11(){
                            matchEnd9(throw new MatchError(x1))
                          };
                          matchEnd9(x: List){
                            x
                          }
                        };
                        val pvs: List = xtract(cc).++(xtract(bb), immutable.this.List.canBuildFrom());
                        val pvss: List = pvs.map({
                          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                            def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                              $anonfun.super.<init>();
                              ()
                            };
                            final def apply(x$1: scala.virtualization.lms.internal.Expressions#TP): scala.virtualization.lms.internal.Expressions#Sym = x$1.sym();
                            <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                            <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                          };
                          (new anonymous class $anonfun($anonfun.this): Function1)
                        }, immutable.this.List.canBuildFrom());
                        def xform(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
                          case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x;
                          case8(){
                            if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
                              {
                                val x3: scala.virtualization.lms.internal.Expressions#TP = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                                if (x3.ne(null))
                                  if (x3.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                                    {
                                      val x5: scala.virtualization.lms.internal.Effects#Reflect = (x3.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                                      if (x5.ne(null))
                                        if (x5.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                                          {
                                            val x6: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x5.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                                            if (x6.ne(null))
                                              if (pvss.contains(x3.sym()))
                                                matchEnd7(new scala.virtualization.lms.internal.Expressions#TP($anonfun.this.$outer, x3.sym(), new scala.virtualization.lms.internal.Effects#Reflect($anonfun.this.$outer, new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x6.k()), x5.summary(), x5.deps().:+(loopSym, immutable.this.List.canBuildFrom()))))
                                              else
                                                case9()
                                            else
                                              case9()
                                          }
                                        else
                                          case9()
                                      else
                                        case9()
                                    }
                                  else
                                    case9()
                                else
                                  case9()
                              }
                            else
                              case9()
                          };
                          case9(){
                            matchEnd7(x1)
                          };
                          matchEnd7(x: scala.virtualization.lms.internal.Expressions#Stm){
                            x
                          }
                        };
                        $anonfun.this.$outer.__assign($anonfun.this.$outer.globalDefs(), $anonfun.this.$outer.globalDefs().map({
                          {
                            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                              def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                $anonfun.super.<init>();
                                ()
                              };
                              final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                              <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                              final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                            };
                            (new anonymous class $anonfun($anonfun.this): Function1)
                          }
                        }, immutable.this.List.canBuildFrom()));
                        $anonfun.this.$outer.__assign($anonfun.this.$outer.localDefs(), $anonfun.this.$outer.localDefs().map({
                          {
                            @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                              def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                $anonfun.super.<init>();
                                ()
                              };
                              final def apply(x: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = xform(x);
                              <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                              <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                              final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                            };
                            (new anonymous class $anonfun($anonfun.this): Function1)
                          }
                        }, immutable.this.List.canBuildFrom()))
                      };
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
                      final <bridge> def apply(v1: Object): Unit = $anonfun.this.apply(v1)
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
                  });
                  SplitEffectsExpFat$class.this.__ifThenElse({
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                      <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                  }, {
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.WhileExp#While($anonfun.this.$outer, $anonfun.this.$outer.projectPureWithSimpleB(x3.cond(), reflect.this.Manifest.Boolean()), $anonfun.this.$outer.projectSimpleB(x3.body())), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 70)})))));
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                  }, {
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                      <specialized> def apply$mcV$sp(): Unit = ();
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                  });
                  new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
                })
              else
                case8()
            }
          else
            case8()
        };
        case8(){
          if (x1.isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
            {
              val x4: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x1.asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
              if (x4.ne(null))
                matchEnd5({
                  val affected: List = u.mayRead().++(u.mayWrite(), immutable.this.List.canBuildFrom()).distinct();
                  affected.foreach({
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(s: scala.virtualization.lms.internal.Expressions#Sym): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x4.k()), $anonfun.this.$outer.projectS(u, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{s}))), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 80)})))));
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
                  });
                  SplitEffectsExpFat$class.this.__ifThenElse({
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                      <specialized> def apply$mcZ$sp(): Boolean = u.maySimple();
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                  }, {
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration($anonfun.this.$outer, x4.k()), $anonfun.this.$outer.projectSimpleS(u), reflect.this.Manifest.Unit(), pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 83)})))));
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                  }, {
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcV$sp with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): Unit = $anonfun.this.apply$mcV$sp();
                      <specialized> def apply$mcV$sp(): Unit = ();
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function0)
                  });
                  new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()).asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]()
                })
              else
                case9()
            }
          else
            case9()
        };
        case9(){
          matchEnd5(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$reflectEffectInternal(x, u, evidence$1, pos.update(reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffectInternal", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 87)}))))))
        };
        matchEnd5(x){
          x
        }
      };
      def projectL(a: List, s: List): List = a.filter({
        @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcZL$sp with Serializable {
          def <init>($outer: scala.virtualization.lms.common.BooleanOpsExp): anonymous class $anonfun = {
            $anonfun.super.<init>();
            ()
          };
          final def apply(x$2: scala.virtualization.lms.internal.Expressions#Sym): Boolean = s.contains(x$2);
          <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BooleanOpsExp = _;
          <synthetic> <stable> def scala$virtualization$lms$common$SplitEffectsExpFat$$anonfun$$$outer(): scala.virtualization.lms.common.BooleanOpsExp = $anonfun.this.$outer;
          final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1);
          final <bridge> def apply(v1: Object): Boolean = $anonfun.this.apply(v1)
        };
        (new anonymous class $anonfun(SplitEffectsExpFat$class.this): Function1)
      });
      def projectS(u: scala.virtualization.lms.internal.Effects#Summary, s: List): scala.virtualization.lms.internal.Effects#Summary = {
        val qual$2: scala.virtualization.lms.internal.Effects#Summary = SplitEffectsExpFat$class.this.Pure();
        val x$26: List = SplitEffectsExpFat$class.this.projectL(u.mayRead(), s);
        val x$27: List = SplitEffectsExpFat$class.this.projectL(u.mstRead(), s);
        val x$28: List = SplitEffectsExpFat$class.this.projectL(u.mayWrite(), s);
        val x$29: List = SplitEffectsExpFat$class.this.projectL(u.mstWrite(), s);
        val x$30: Boolean = qual$2.copy$default$1();
        val x$31: Boolean = qual$2.copy$default$2();
        val x$32: Boolean = qual$2.copy$default$3();
        val x$33: Boolean = qual$2.copy$default$4();
        val x$34: Boolean = qual$2.copy$default$5();
        qual$2.copy(x$30, x$31, x$32, x$33, x$34, x$26, x$27, x$28, x$29)
      };
      def projectB(b: scala.virtualization.lms.internal.Blocks#Block, s: List): scala.virtualization.lms.internal.Blocks#Block = {
        case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
        case7(){
          if (x1.ne(null))
            {
              val o9: Option = SplitEffectsExpFat$class.this.Def().unapply(x1.res());
              if (o9.isEmpty().unary_!())
                if (o9.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                  {
                    val x5: scala.virtualization.lms.internal.Effects#Reify = (o9.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                    if (x5.ne(null))
                      matchEnd6({
                        val deps: List = SplitEffectsExpFat$class.this.calculateDependencies(x5.effects(), SplitEffectsExpFat$class.this.Write(s));
                        new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()), SplitEffectsExpFat$class.this.projectS(x5.summary(), s), deps), reflect.this.Manifest.Unit(), reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 103)})))))
                      })
                    else
                      case8()
                  }
                else
                  case8()
              else
                case8()
            }
          else
            case8()
        };
        case8(){
          matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit())))
        };
        matchEnd6(x){
          x
        }
      };
      def projectSimpleS(u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Effects#Summary = {
        val qual$1: scala.virtualization.lms.internal.Effects#Summary = SplitEffectsExpFat$class.this.Pure();
        val x$17: Boolean = u.maySimple();
        val x$18: Boolean = u.mstSimple();
        val x$19: Boolean = qual$1.copy$default$3();
        val x$20: Boolean = qual$1.copy$default$4();
        val x$21: Boolean = qual$1.copy$default$5();
        val x$22: List = qual$1.copy$default$6();
        val x$23: List = qual$1.copy$default$7();
        val x$24: List = qual$1.copy$default$8();
        val x$25: List = qual$1.copy$default$9();
        qual$1.copy(x$17, x$18, x$19, x$20, x$21, x$22, x$23, x$24, x$25)
      };
      def projectSimpleB(b: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Blocks#Block = {
        case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
        case7(){
          if (x1.ne(null))
            {
              val o9: Option = SplitEffectsExpFat$class.this.Def().unapply(x1.res());
              if (o9.isEmpty().unary_!())
                if (o9.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                  {
                    val x5: scala.virtualization.lms.internal.Effects#Reify = (o9.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                    if (x5.ne(null))
                      matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit()), SplitEffectsExpFat$class.this.projectSimpleS(x5.summary()), SplitEffectsExpFat$class.this.calculateDependencies(x5.effects(), SplitEffectsExpFat$class.this.Simple())), reflect.this.Manifest.Unit(), reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 110)}))))))
                    else
                      case8()
                  }
                else
                  case8()
              else
                case8()
            }
          else
            case8()
        };
        case8(){
          matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, new scala.virtualization.lms.internal.Expressions#Const(SplitEffectsExpFat$class.this, (), reflect.this.Manifest.Unit())))
        };
        matchEnd6(x){
          x
        }
      };
      def projectPureS(u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Effects#Summary = SplitEffectsExpFat$class.this.Pure();
      def projectPureB(b: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Blocks#Block = {
        case <synthetic> val x1: scala.virtualization.lms.internal.Blocks#Block = b;
        case7(){
          if (x1.ne(null))
            {
              val o9: Option = SplitEffectsExpFat$class.this.Def().unapply(x1.res());
              if (o9.isEmpty().unary_!())
                if (o9.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                  {
                    val x5: scala.virtualization.lms.internal.Effects#Reify = (o9.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                    if (x5.ne(null))
                      matchEnd6(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, x5.x()))
                    else
                      case8()
                  }
                else
                  case8()
              else
                case8()
            }
          else
            case8()
        };
        case8(){
          matchEnd6(b)
        };
        matchEnd6(x){
          x
        }
      };
      def projectPureWithB(b: scala.virtualization.lms.internal.Blocks#Block, s: List, evidence$2: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block = {
        case <synthetic> val x1: Tuple2 = new Tuple2(SplitEffectsExpFat$class.this.projectPureB(b), SplitEffectsExpFat$class.this.projectB(b, s));
        case14(){
          if (x1.ne(null))
            if (x1._1().ne(null))
              if (x1._2().ne(null))
                {
                  val o16: Option = SplitEffectsExpFat$class.this.Def().unapply(x1._2().res());
                  if (o16.isEmpty().unary_!())
                    if (o16.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                      {
                        val x8: scala.virtualization.lms.internal.Effects#Reify = (o16.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                        if (x8.ne(null))
                          if (x8.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#Const]())
                            {
                              val x10: scala.virtualization.lms.internal.Expressions#Const = (x8.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#Const](): scala.virtualization.lms.internal.Expressions#Const);
                              if (x10.ne(null))
                                if (().==(x10.x()))
                                  {
                                    val x12: scala.runtime.BoxedUnit = x10.x();
                                    matchEnd13(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, x1._1().res(), x8.summary(), x8.effects()), evidence$2, reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 122)}))))))
                                  }
                                else
                                  case15()
                              else
                                case15()
                            }
                          else
                            case15()
                        else
                          case15()
                      }
                    else
                      case15()
                  else
                    case15()
                }
              else
                case15()
            else
              case15()
          else
            case15()
        };
        case15(){
          if (x1.ne(null))
            matchEnd13(x1._1())
          else
            case17()
        };
        case17(){
          matchEnd13(throw new MatchError(x1))
        };
        matchEnd13(x){
          x
        }
      };
      def projectPureWithSimpleB(b: scala.virtualization.lms.internal.Blocks#Block, evidence$3: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block = {
        case <synthetic> val x1: Tuple2 = new Tuple2(SplitEffectsExpFat$class.this.projectPureB(b), SplitEffectsExpFat$class.this.projectSimpleB(b));
        case14(){
          if (x1.ne(null))
            if (x1._1().ne(null))
              if (x1._2().ne(null))
                {
                  val o16: Option = SplitEffectsExpFat$class.this.Def().unapply(x1._2().res());
                  if (o16.isEmpty().unary_!())
                    if (o16.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                      {
                        val x8: scala.virtualization.lms.internal.Effects#Reify = (o16.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                        if (x8.ne(null))
                          if (x8.x().isInstanceOf[scala.virtualization.lms.internal.Expressions#Const]())
                            {
                              val x10: scala.virtualization.lms.internal.Expressions#Const = (x8.x().asInstanceOf[scala.virtualization.lms.internal.Expressions#Const](): scala.virtualization.lms.internal.Expressions#Const);
                              if (x10.ne(null))
                                if (().==(x10.x()))
                                  {
                                    val x12: scala.runtime.BoxedUnit = x10.x();
                                    matchEnd13(new scala.virtualization.lms.internal.Blocks#Block(SplitEffectsExpFat$class.this, SplitEffectsExpFat$class.this.toAtom(new scala.virtualization.lms.internal.Effects#Reify(SplitEffectsExpFat$class.this, x1._1().res(), x8.summary(), x8.effects()), evidence$3, reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "toAtom", "SplitEffectsExpFat", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 128)}))))))
                                  }
                                else
                                  case15()
                              else
                                case15()
                            }
                          else
                            case15()
                        else
                          case15()
                      }
                    else
                      case15()
                  else
                    case15()
                }
              else
                case15()
            else
              case15()
          else
            case15()
        };
        case15(){
          if (x1.ne(null))
            matchEnd13(x1._1())
          else
            case17()
        };
        case17(){
          matchEnd13(throw new MatchError(x1))
        };
        matchEnd13(x){
          x
        }
      };
      @volatile <synthetic> var scala$virtualization$lms$common$SplitEffectsExpFat$$SimpleFatWhile$module: ... = _;
      <synthetic> <stable> def SimpleFatWhile(): ... = new ...(SplitEffectsExpFat$class.this);
      override def syms(e: Object): List = {
        case <synthetic> val x1: Object = e;
        case4(){
          if (x1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().&&((x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile).scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer().eq(SplitEffectsExpFat$class.this)))
            {
              val x2: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
              if (x2.ne(null))
                matchEnd3(SplitEffectsExpFat$class.this.syms(x2.cond()).++(SplitEffectsExpFat$class.this.syms(x2.body()), immutable.this.List.canBuildFrom()).++(SplitEffectsExpFat$class.this.syms(x2.extradeps()), immutable.this.List.canBuildFrom()))
              else
                case5()
            }
          else
            case5()
        };
        case5(){
          matchEnd3(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$syms(e))
        };
        matchEnd3(x){
          x
        }
      };
      override def boundSyms(e: Object): List = {
        case <synthetic> val x1: Object = e;
        case4(){
          if (x1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().&&((x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile).scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer().eq(SplitEffectsExpFat$class.this)))
            {
              val x2: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
              if (x2.ne(null))
                matchEnd3({
                  <synthetic> val x$3: List = SplitEffectsExpFat$class.this.effectSyms(x2.cond());
                  SplitEffectsExpFat$class.this.effectSyms(x2.body()).:::(x$3)
                })
              else
                case5()
            }
          else
            case5()
        };
        case5(){
          matchEnd3(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$boundSyms(e))
        };
        matchEnd3(x){
          x
        }
      };
      override def symsFreq(e: Object): List = {
        case <synthetic> val x1: Object = e;
        case4(){
          if (x1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().&&((x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile).scala$virtualization$lms$common$SplitEffectsExpFat$SimpleFatWhile$$$outer().eq(SplitEffectsExpFat$class.this)))
            {
              val x2: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
              if (x2.ne(null))
                matchEnd3(SplitEffectsExpFat$class.this.freqHot(x2.cond()).++(SplitEffectsExpFat$class.this.freqHot(x2.body()), immutable.this.List.canBuildFrom()).++(SplitEffectsExpFat$class.this.freqNormal(x2.extradeps()), immutable.this.List.canBuildFrom()))
              else
                case5()
            }
          else
            case5()
        };
        case5(){
          matchEnd3(SplitEffectsExpFat$class.this.scala$virtualization$lms$common$SplitEffectsExpFat$$super$symsFreq(e))
        };
        matchEnd3(x){
          x
        }
      }
    };
    abstract trait PreviousIterationDummyExp$class extends Object with scala.virtualization.lms.common.BaseFatExp with scala.virtualization.lms.common.EffectExp$class with scala.virtualization.lms.common.PreviousIterationDummyExp {
      def /*PreviousIterationDummyExp$class*/$init$(): Unit = {
        ()
      };
      @volatile <synthetic> var scala$virtualization$lms$common$PreviousIterationDummyExp$$PreviousIteration$module: ... = _;
      <synthetic> <stable> def PreviousIteration(): ... = new ...(PreviousIterationDummyExp$class.this);
      @volatile <synthetic> var scala$virtualization$lms$common$PreviousIterationDummyExp$$SimpleFatPrevious$module: ... = _;
      <synthetic> <stable> def SimpleFatPrevious(): ... = new ...(PreviousIterationDummyExp$class.this);
      def reflectPreviousDummy(k: scala.virtualization.lms.internal.Expressions#Exp, u: scala.virtualization.lms.internal.Effects#Summary): scala.virtualization.lms.internal.Expressions#Exp = PreviousIterationDummyExp$class.this.reflectEffect(new scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration(PreviousIterationDummyExp$class.this, k), u, reflect.this.Manifest.Unit(), reflect.this.SourceContext.apply("/home/stivo/master/distributed/virt/src/common/SplitEffects.scala", "reflectEffect", "PreviousIterationDummyExp", immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[Tuple2]{new Tuple2$mcLI$sp(null, 164)}))))
    };
    abstract trait BaseGenSplitEffects$class extends Object with scala.virtualization.lms.common.BaseGenIfThenElseFat$class with scala.virtualization.lms.internal.GenericFatCodegen$class with scala.virtualization.lms.common.BaseGenSplitEffects {
      def /*BaseGenSplitEffects$class*/$init$(): Unit = {
        ()
      };
      override def reifyBlock(x: Function0, evidence$4: scala.reflect.Manifest): scala.virtualization.lms.internal.Blocks#Block = {
        val sup: scala.virtualization.lms.internal.Blocks#Block = BaseGenSplitEffects$class.this.scala$virtualization$lms$common$BaseGenSplitEffects$$super$reifyBlock(x, evidence$4);
        BaseGenSplitEffects$class.this.IR().projectPureWithSimpleB(sup, evidence$4)
      };
      override def fatten(e: scala.virtualization.lms.internal.Expressions#Stm): scala.virtualization.lms.internal.Expressions#Stm = {
        var rc12: Boolean = false;
        var x2: scala.virtualization.lms.internal.Expressions#TP = (null: scala.virtualization.lms.internal.Expressions#TP);
        var rc13: Boolean = false;
        var x6: scala.virtualization.lms.internal.Effects#Reflect = (null: scala.virtualization.lms.internal.Effects#Reflect);
        {
          case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = e;
          case15(){
            if (x1.isInstanceOf[scala.virtualization.lms.internal.Expressions#TP]())
              {
                rc12 = true;
                x2 = (x1.asInstanceOf[scala.virtualization.lms.internal.Expressions#TP](): scala.virtualization.lms.internal.Expressions#TP);
                if (x2.ne(null))
                  if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                    {
                      val x3: scala.virtualization.lms.common.WhileExp#While = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                      if (x3.ne(null))
                        matchEnd14(new scala.virtualization.lms.internal.FatExpressions#TTP(BaseGenSplitEffects$class.this.IR, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{x2.sym()})), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.common.WhileExp#While]{x3})), new scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile(BaseGenSplitEffects$class.this.IR, x3.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Blocks#Block]{x3.body()})))))
                      else
                        case16()
                    }
                  else
                    case16()
                else
                  case16()
              }
            else
              case16()
          };
          case16(){
            if (rc12)
              if (x2.rhs().isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
                {
                  rc13 = true;
                  x6 = (x2.rhs().asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
                  if (x6.ne(null))
                    if (x6.x().isInstanceOf[scala.virtualization.lms.common.WhileExp#While]())
                      {
                        val x7: scala.virtualization.lms.common.WhileExp#While = (x6.x().asInstanceOf[scala.virtualization.lms.common.WhileExp#While](): scala.virtualization.lms.common.WhileExp#While);
                        if (x7.ne(null))
                          matchEnd14({
                            val x: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = new scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile(BaseGenSplitEffects$class.this.IR, x7.cond(), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Blocks#Block]{x7.body()})));
                            x.extradeps_=(x6.deps().asInstanceOf[List]());
                            new scala.virtualization.lms.internal.FatExpressions#TTP(BaseGenSplitEffects$class.this.IR, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{x2.sym()})), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Effects#Reflect]{x6})), x)
                          })
                        else
                          case17()
                      }
                    else
                      case17()
                  else
                    case17()
                }
              else
                case17()
            else
              case17()
          };
          case17(){
            if (rc13)
              if (x6.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                {
                  val x11: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x6.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                  if (x11.ne(null))
                    matchEnd14({
                      val x: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = new scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious(BaseGenSplitEffects$class.this.IR, x11.k(), x6.deps().asInstanceOf[List]());
                      new scala.virtualization.lms.internal.FatExpressions#TTP(BaseGenSplitEffects$class.this.IR, immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Expressions#Sym]{x2.sym()})), immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Effects#Reflect]{x6})), x)
                    })
                  else
                    case18()
                }
              else
                case18()
            else
              case18()
          };
          case18(){
            matchEnd14(BaseGenSplitEffects$class.this.scala$virtualization$lms$common$BaseGenSplitEffects$$super$fatten(e))
          };
          matchEnd14(x){
            x
          }
        }
      };
      override def fattenAll(e: List): List = {
        val e1: List = BaseGenSplitEffects$class.this.scala$virtualization$lms$common$BaseGenSplitEffects$$super$fattenAll(e);
        val e2: List = e1.collect({
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction with Serializable {
            def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final override def applyOrElse(x$1: scala.virtualization.lms.internal.Expressions#Stm, default: Function1): Object = {
              var rc8: Boolean = false;
              var x2: scala.virtualization.lms.internal.FatExpressions#TTP = (null: scala.virtualization.lms.internal.FatExpressions#TTP);
              {
                case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x$1;
                case10(){
                  if (x1.isInstanceOf[scala.virtualization.lms.internal.FatExpressions#TTP]())
                    {
                      rc8 = true;
                      x2 = (x1.asInstanceOf[scala.virtualization.lms.internal.FatExpressions#TTP](): scala.virtualization.lms.internal.FatExpressions#TTP);
                      if (x2.ne(null))
                        if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse]())
                          {
                            val x3: scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse](): scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse);
                            if (x3.ne(null))
                              matchEnd9(((x2: Object): Object))
                            else
                              case11()
                          }
                        else
                          case11()
                      else
                        case11()
                    }
                  else
                    case11()
                };
                case11(){
                  if (rc8)
                    if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]())
                      {
                        val x5: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
                        if (x5.ne(null))
                          matchEnd9(((x2: Object): Object))
                        else
                          case12()
                      }
                    else
                      case12()
                  else
                    case12()
                };
                case12(){
                  if (rc8)
                    if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]())
                      {
                        val x7: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious](): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious);
                        if (x7.ne(null))
                          matchEnd9(((x2: Object): Object))
                        else
                          case13()
                      }
                    else
                      case13()
                  else
                    case13()
                };
                case13(){
                  matchEnd9(default.apply(x$1))
                };
                matchEnd9(x){
                  x
                }
              }
            };
            final def isDefinedAt(x$1: scala.virtualization.lms.internal.Expressions#Stm): Boolean = {
              var rc8: Boolean = false;
              var x2: scala.virtualization.lms.internal.FatExpressions#TTP = (null: scala.virtualization.lms.internal.FatExpressions#TTP);
              {
                case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Stm = x$1;
                case10(){
                  if (x1.isInstanceOf[scala.virtualization.lms.internal.FatExpressions#TTP]())
                    {
                      rc8 = true;
                      x2 = (x1.asInstanceOf[scala.virtualization.lms.internal.FatExpressions#TTP](): scala.virtualization.lms.internal.FatExpressions#TTP);
                      if (x2.ne(null))
                        if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse]())
                          {
                            val x3: scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse](): scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse);
                            if (x3.ne(null))
                              matchEnd9(true)
                            else
                              case11()
                          }
                        else
                          case11()
                      else
                        case11()
                    }
                  else
                    case11()
                };
                case11(){
                  if (rc8)
                    if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]())
                      {
                        val x5: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
                        if (x5.ne(null))
                          matchEnd9(true)
                        else
                          case12()
                      }
                    else
                      case12()
                  else
                    case12()
                };
                case12(){
                  if (rc8)
                    if (x2.rhs().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]())
                      {
                        val x7: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = (x2.rhs().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious](): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious);
                        if (x7.ne(null))
                          matchEnd9(true)
                        else
                          case13()
                      }
                    else
                      case13()
                  else
                    case13()
                };
                case13(){
                  matchEnd9(false)
                };
                matchEnd9(x){
                  x
                }
              }
            };
            <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
            <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
            final <bridge> def isDefinedAt(x: Object): Boolean = $anonfun.this.isDefinedAt(x);
            final override <bridge> def applyOrElse(x: Object, default: Function1): Object = $anonfun.this.applyOrElse(x, default)
          };
          new anonymous class $anonfun(BaseGenSplitEffects$class.this)
        }, immutable.this.List.canBuildFrom());
        val m: scala.collection.immutable.Map = e2.groupBy({
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
            def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(x$1: scala.virtualization.lms.internal.FatExpressions#TTP): Tuple2 = {
              case <synthetic> val x1: scala.virtualization.lms.internal.FatExpressions#TTP = x$1;
              case13(){
                if (x1.ne(null))
                  if (x1.rhs().isInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse]())
                    {
                      val x2: scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse = (x1.rhs().asInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse](): scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse);
                      if (x2.ne(null))
                        matchEnd12(new Tuple2(x2.cond(), "if"))
                      else
                        case14()
                    }
                  else
                    case14()
                else
                  case14()
              };
              case14(){
                if (x1.ne(null))
                  if (x1.rhs().isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]())
                    {
                      val x4: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
                      if (x4.ne(null))
                        if (x4.cond().ne(null))
                          {
                            val o16: Option = $anonfun.this.$outer.IR().Def().unapply(x4.cond().res());
                            if (o16.isEmpty().unary_!())
                              if (o16.get().isInstanceOf[scala.virtualization.lms.internal.Effects#Reify]())
                                {
                                  val x10: scala.virtualization.lms.internal.Effects#Reify = (o16.get().asInstanceOf[scala.virtualization.lms.internal.Effects#Reify](): scala.virtualization.lms.internal.Effects#Reify);
                                  if (x10.ne(null))
                                    matchEnd12(new Tuple2(x10.x(), "while"))
                                  else
                                    case15()
                                }
                              else
                                case15()
                            else
                              case15()
                          }
                        else
                          case15()
                      else
                        case15()
                    }
                  else
                    case15()
                else
                  case15()
              };
              case15(){
                if (x1.ne(null))
                  if (x1.rhs().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]())
                    {
                      val x11: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = (x1.rhs().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious](): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious);
                      if (x11.ne(null))
                        matchEnd12(new Tuple2(x11.k(), "prev"))
                      else
                        case17()
                    }
                  else
                    case17()
                else
                  case17()
              };
              case17(){
                matchEnd12(throw new MatchError(x1))
              };
              matchEnd12(x){
                x
              }
            };
            <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
            <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
          };
          new anonymous class $anonfun(BaseGenSplitEffects$class.this)
        });
        val e3: List = e1.diff(e2);
        val g1: scala.collection.immutable.Iterable = m.map({
          @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
            def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
              $anonfun.super.<init>();
              ()
            };
            final def apply(x$1: Tuple2): scala.virtualization.lms.internal.FatExpressions#TTP = {
              case <synthetic> val x1: Tuple2 = x$1;
              case17(){
                if (x1.ne(null))
                  if (x1._1().ne(null))
                    if (x1._1()._1().ne(null))
                      {
                        val x8: scala.virtualization.lms.internal.Expressions#Exp = x1._1()._1();
                        if ("if".==(x1._1()._2()))
                          {
                            val x9: String = x1._1()._2();
                            if (x1._2().ne(null))
                              {
                                val x10: List = x1._2();
                                matchEnd16(new scala.virtualization.lms.internal.FatExpressions#TTP($anonfun.this.$outer.IR, x10.flatMap({
                                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                      $anonfun.super.<init>();
                                      ()
                                    };
                                    final def apply(x$4: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$4.lhs();
                                    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                  };
                                  (new anonymous class $anonfun($anonfun.this): Function1)
                                }, immutable.this.List.canBuildFrom()), x10.flatMap({
                                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                      $anonfun.super.<init>();
                                      ()
                                    };
                                    final def apply(x$5: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$5.mhs();
                                    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                  };
                                  (new anonymous class $anonfun($anonfun.this): Function1)
                                }, immutable.this.List.canBuildFrom()), new scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse($anonfun.this.$outer.IR, x8, x10.flatMap({
                                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                      $anonfun.super.<init>();
                                      ()
                                    };
                                    final def apply(x$6: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$6.rhs().asInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse]().thenp();
                                    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                  };
                                  (new anonymous class $anonfun($anonfun.this): Function1)
                                }, immutable.this.List.canBuildFrom()), x10.flatMap({
                                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                      $anonfun.super.<init>();
                                      ()
                                    };
                                    final def apply(x$7: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$7.rhs().asInstanceOf[scala.virtualization.lms.common.IfThenElseFatExp#SimpleFatIfThenElse]().elsep();
                                    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                  };
                                  (new anonymous class $anonfun($anonfun.this): Function1)
                                }, immutable.this.List.canBuildFrom()))))
                              }
                            else
                              case18()
                          }
                        else
                          case18()
                      }
                    else
                      case18()
                  else
                    case18()
                else
                  case18()
              };
              case18(){
                if (x1.ne(null))
                  if (x1._1().ne(null))
                    if ("while".==(x1._1()._2()))
                      {
                        val x11: String = x1._1()._2();
                        if (x1._2().ne(null))
                          {
                            val x12: List = x1._2();
                            matchEnd16({
                              val x: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = new scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile($anonfun.this.$outer.IR, x12.map({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(x$8: scala.virtualization.lms.internal.FatExpressions#TTP): scala.virtualization.lms.internal.Blocks#Block = x$8.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().cond();
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).apply(0), x12.flatMap({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final def apply(x$9: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$9.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().body();
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                };
                                (new anonymous class $anonfun($anonfun.this): Function1)
                              }, immutable.this.List.canBuildFrom()));
                              x.extradeps_=(x12.flatMap({
  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
      $anonfun.super.<init>();
      ()
    };
    final def apply(x$10: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$10.rhs().asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]().extradeps();
    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
  };
  (new anonymous class $anonfun($anonfun.this): Function1)
}, immutable.this.List.canBuildFrom()).diff(x12.flatMap({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final def apply(x$11: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$11.lhs();
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                };
                                (new anonymous class $anonfun($anonfun.this): Function1)
                              }, immutable.this.List.canBuildFrom())));
                              new scala.virtualization.lms.internal.FatExpressions#TTP($anonfun.this.$outer.IR, x12.flatMap({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final def apply(x$12: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$12.lhs();
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                };
                                (new anonymous class $anonfun($anonfun.this): Function1)
                              }, immutable.this.List.canBuildFrom()), x12.flatMap({
                                @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                  def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                    $anonfun.super.<init>();
                                    ()
                                  };
                                  final def apply(x$13: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$13.mhs();
                                  <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                  <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                  final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                };
                                (new anonymous class $anonfun($anonfun.this): Function1)
                              }, immutable.this.List.canBuildFrom()), x)
                            })
                          }
                        else
                          case19()
                      }
                    else
                      case19()
                  else
                    case19()
                else
                  case19()
              };
              case19(){
                if (x1.ne(null))
                  if (x1._1().ne(null))
                    if (x1._1()._1().isInstanceOf[scala.virtualization.lms.internal.Expressions#Exp]())
                      {
                        val x13: scala.virtualization.lms.internal.Expressions#Exp = (x1._1()._1().asInstanceOf[scala.virtualization.lms.internal.Expressions#Exp](): scala.virtualization.lms.internal.Expressions#Exp);
                        if ("prev".==(x1._1()._2()))
                          {
                            val x14: String = x1._1()._2();
                            if (x1._2().ne(null))
                              {
                                val x15: List = x1._2();
                                matchEnd16(new scala.virtualization.lms.internal.FatExpressions#TTP($anonfun.this.$outer.IR, x15.flatMap({
                                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                      $anonfun.super.<init>();
                                      ()
                                    };
                                    final def apply(x$14: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$14.lhs();
                                    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                  };
                                  (new anonymous class $anonfun($anonfun.this): Function1)
                                }, immutable.this.List.canBuildFrom()), x15.flatMap({
                                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                      $anonfun.super.<init>();
                                      ()
                                    };
                                    final def apply(x$15: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$15.mhs();
                                    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                  };
                                  (new anonymous class $anonfun($anonfun.this): Function1)
                                }, immutable.this.List.canBuildFrom()), new scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious($anonfun.this.$outer.IR, x13, x15.flatMap({
                                  @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                                    def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
                                      $anonfun.super.<init>();
                                      ()
                                    };
                                    final def apply(x$16: scala.virtualization.lms.internal.FatExpressions#TTP): List = x$16.rhs().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]().extra();
                                    <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
                                    <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
                                    final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                                  };
                                  (new anonymous class $anonfun($anonfun.this): Function1)
                                }, immutable.this.List.canBuildFrom()))))
                              }
                            else
                              case20()
                          }
                        else
                          case20()
                      }
                    else
                      case20()
                  else
                    case20()
                else
                  case20()
              };
              case20(){
                matchEnd16(throw new MatchError(x1))
              };
              matchEnd16(x){
                x
              }
            };
            <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
            <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
            final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
          };
          new anonymous class $anonfun(BaseGenSplitEffects$class.this)
        }, immutable.this.Iterable.canBuildFrom());
        val r: List = e3.++(g1, immutable.this.List.canBuildFrom());
        r
      };
      override def emitFatNode(symList: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit = {
        case <synthetic> val x1: scala.virtualization.lms.internal.FatExpressions#FatDef = rhs;
        case4(){
          if (x1.isInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile]())
            {
              val x2: scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile = (x1.asInstanceOf[scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile](): scala.virtualization.lms.common.SplitEffectsExpFat#SimpleFatWhile);
              if (x2.ne(null))
                matchEnd3({
                  def quoteList(xs: List): String = BaseGenSplitEffects$class.this.IR().__ifThenElse({
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0$mcZ$sp with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): Boolean = $anonfun.this.apply$mcZ$sp();
                      <specialized> def apply$mcZ$sp(): Boolean = xs.length().>(1);
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(BaseGenSplitEffects$class.this): Function0)
                  }, {
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): String = xs.map({
  {
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(x: scala.virtualization.lms.internal.Expressions#Exp): String = $anonfun.this.$outer.scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer().quote(x);
      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
      <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
    };
    (new anonymous class $anonfun($anonfun.this): Function1)
  }
}, immutable.this.List.canBuildFrom()).mkString("(", ",", ")");
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(BaseGenSplitEffects$class.this): Function0)
                  }, {
                    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction0 with Serializable {
                      def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
                        $anonfun.super.<init>();
                        ()
                      };
                      final def apply(): String = xs.map({
  {
    @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
      def <init>($outer: anonymous class $anonfun): anonymous class $anonfun = {
        $anonfun.super.<init>();
        ()
      };
      final def apply(x: scala.virtualization.lms.internal.Expressions#Exp): String = $anonfun.this.$outer.scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer().quote(x);
      <synthetic> <paramaccessor> private[this] val $outer: anonymous class $anonfun = _;
      <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$anonfun$$$outer(): anonymous class $anonfun = $anonfun.this.$outer;
      final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
    };
    (new anonymous class $anonfun($anonfun.this): Function1)
  }
}, immutable.this.List.canBuildFrom()).mkString(",");
                      <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
                      <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
                      final <bridge> def apply(): Object = $anonfun.this.apply()
                    };
                    (new anonymous class $anonfun(BaseGenSplitEffects$class.this): Function0)
                  });
                  BaseGenSplitEffects$class.this.stream().println("while ({ // ".+(symList));
                  BaseGenSplitEffects$class.this.emitFatBlock(immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Blocks#Block]{x2.cond()})));
                  BaseGenSplitEffects$class.this.stream().println(quoteList(immutable.this.List.apply(scala.this.Predef.wrapRefArray(Array[scala.virtualization.lms.internal.Blocks#Block]{x2.cond()})).map({
                    {
                      @SerialVersionUID(0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1 with Serializable {
                        def <init>($outer: scala.virtualization.lms.common.BaseGenSplitEffects): anonymous class $anonfun = {
                          $anonfun.super.<init>();
                          ()
                        };
                        final def apply(s: scala.virtualization.lms.internal.Blocks#Block): scala.virtualization.lms.internal.Expressions#Exp = $anonfun.this.$outer.getBlockResult(s);
                        <synthetic> <paramaccessor> private[this] val $outer: scala.virtualization.lms.common.BaseGenSplitEffects = _;
                        <synthetic> <stable> def scala$virtualization$lms$common$BaseGenSplitEffects$$anonfun$$$outer(): scala.virtualization.lms.common.BaseGenSplitEffects = $anonfun.this.$outer;
                        final <bridge> def apply(v1: Object): Object = $anonfun.this.apply(v1)
                      };
                      (new anonymous class $anonfun(BaseGenSplitEffects$class.this): Function1)
                    }
                  }, immutable.this.List.canBuildFrom())));
                  BaseGenSplitEffects$class.this.stream().println("}) {");
                  BaseGenSplitEffects$class.this.emitFatBlock(x2.body());
                  BaseGenSplitEffects$class.this.stream().println("}")
                })
              else
                case5()
            }
          else
            case5()
        };
        case5(){
          matchEnd3(BaseGenSplitEffects$class.this.scala$virtualization$lms$common$BaseGenSplitEffects$$super$emitFatNode(symList, rhs))
        };
        matchEnd3(x){
          x
        }
      }
    };
    abstract trait ScalaGenPreviousIterationDummy$class extends Object with scala.virtualization.lms.common.ScalaGenFat with scala.virtualization.lms.common.ScalaGenPreviousIterationDummy {
      def /*ScalaGenPreviousIterationDummy$class*/$init$(): Unit = {
        ()
      };
      override def emitNode(sym: scala.virtualization.lms.internal.Expressions#Sym, rhs: scala.virtualization.lms.internal.Expressions#Def): Unit = {
        case <synthetic> val x1: scala.virtualization.lms.internal.Expressions#Def = rhs;
        case6(){
          if (x1.isInstanceOf[scala.virtualization.lms.internal.Effects#Reflect]())
            {
              val x3: scala.virtualization.lms.internal.Effects#Reflect = (x1.asInstanceOf[scala.virtualization.lms.internal.Effects#Reflect](): scala.virtualization.lms.internal.Effects#Reflect);
              if (x3.ne(null))
                if (x3.x().isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration]())
                  {
                    val x4: scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration = (x3.x().asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration](): scala.virtualization.lms.common.PreviousIterationDummyExp#PreviousIteration);
                    if (x4.ne(null))
                      matchEnd5(())
                    else
                      case7()
                  }
                else
                  case7()
              else
                case7()
            }
          else
            case7()
        };
        case7(){
          matchEnd5(ScalaGenPreviousIterationDummy$class.this.scala$virtualization$lms$common$ScalaGenPreviousIterationDummy$$super$emitNode(sym, rhs))
        };
        matchEnd5(x){
          x
        }
      };
      override def emitFatNode(symList: List, rhs: scala.virtualization.lms.internal.FatExpressions#FatDef): Unit = {
        case <synthetic> val x1: scala.virtualization.lms.internal.FatExpressions#FatDef = rhs;
        case4(){
          if (x1.isInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious]())
            {
              val x2: scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious = (x1.asInstanceOf[scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious](): scala.virtualization.lms.common.PreviousIterationDummyExp#SimpleFatPrevious);
              if (x2.ne(null))
                matchEnd3(ScalaGenPreviousIterationDummy$class.this.stream().println("// dummy placeholder for previous iteration: ".+(symList).+(" = ").+(x2.k()).+(" / ").+(x2.extra())))
              else
                case5()
            }
          else
            case5()
        };
        case5(){
          matchEnd3(ScalaGenPreviousIterationDummy$class.this.scala$virtualization$lms$common$ScalaGenPreviousIterationDummy$$super$emitFatNode(symList, rhs))
        };
        matchEnd3(x){
          x
        }
      }
    }
  }
}

     while compiling:  /home/stivo/master/distributed/virt/src/common/SplitEffects.scala
       current phase:  erasure
     library version:  version 2.10.0-20120504-113610-33598fa5dd
    compiler version:  version 2.10.0-20120504-113610-33598fa5dd
  reconstructed args:  -d /home/stivo/master/distributed/virt/target/scala-2.10/classes -P:continuations:enable -Yvirtualize -classpath /home/stivo/master/distributed/virt/target/scala-2.10/classes:/home/stivo/.ivy2/cache/com.typesafe/config/jars/config-0.4.0.jar:/home/stivo/.sbt/boot/org.scala-lang.virtualized.scala-2.10.0-M3/lib/scala-compiler.jar -Xplugin:/home/stivo/.ivy2/cache/org.scala-lang.plugins/continuations/jars/continuations-2.10.0-M3.jar -bootclasspath /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/netx.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/plugin.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rhino.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/classes:/home/stivo/.sbt/boot/org.scala-lang.virtualized.scala-2.10.0-M3/lib/scala-library.jar

unhandled exception while transforming SplitEffects.scala
[0m[[31merror[0m] [0m[0m
[0m[[31merror[0m] [0m     while compiling:  /home/stivo/master/distributed/virt/src/common/SplitEffects.scala[0m
[0m[[31merror[0m] [0m       current phase:  erasure[0m
[0m[[31merror[0m] [0m     library version:  version 2.10.0-20120504-113610-33598fa5dd[0m
[0m[[31merror[0m] [0m    compiler version:  version 2.10.0-20120504-113610-33598fa5dd[0m
[0m[[31merror[0m] [0m  reconstructed args:  -d /home/stivo/master/distributed/virt/target/scala-2.10/classes -P:continuations:enable -Yvirtualize -classpath /home/stivo/master/distributed/virt/target/scala-2.10/classes:/home/stivo/.ivy2/cache/com.typesafe/config/jars/config-0.4.0.jar:/home/stivo/.sbt/boot/org.scala-lang.virtualized.scala-2.10.0-M3/lib/scala-compiler.jar -Xplugin:/home/stivo/.ivy2/cache/org.scala-lang.plugins/continuations/jars/continuations-2.10.0-M3.jar -bootclasspath /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/netx.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/plugin.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rhino.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/classes:/home/stivo/.sbt/boot/org.scala-lang.virtualized.scala-2.10.0-M3/lib/scala-library.jar[0m
[0m[[31merror[0m] [0m[0m
[0m[[31merror[0m] [0muncaught exception during compilation: scala.reflect.internal.FatalError[0m
[0m[[31merror[0m] [0m{file:/home/stivo/master/distributed/virt/}LMS/compile:[31mcompile[0m: scala.reflect.internal.FatalError: [0m
[0m[[31merror[0m] [0m     while compiling:  /home/stivo/master/distributed/virt/src/common/SplitEffects.scala[0m
[0m[[31merror[0m] [0m       current phase:  posterasure[0m
[0m[[31merror[0m] [0m     library version:  version 2.10.0-20120504-113610-33598fa5dd[0m
[0m[[31merror[0m] [0m    compiler version:  version 2.10.0-20120504-113610-33598fa5dd[0m
[0m[[31merror[0m] [0m  reconstructed args:  -d /home/stivo/master/distributed/virt/target/scala-2.10/classes -P:continuations:enable -Yvirtualize -classpath /home/stivo/master/distributed/virt/target/scala-2.10/classes:/home/stivo/.ivy2/cache/com.typesafe/config/jars/config-0.4.0.jar:/home/stivo/.sbt/boot/org.scala-lang.virtualized.scala-2.10.0-M3/lib/scala-compiler.jar -Xplugin:/home/stivo/.ivy2/cache/org.scala-lang.plugins/continuations/jars/continuations-2.10.0-M3.jar -bootclasspath /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/netx.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/plugin.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rhino.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/classes:/home/stivo/.sbt/boot/org.scala-lang.virtualized.scala-2.10.0-M3/lib/scala-library.jar[0m
[0m[[31merror[0m] [0m[0m
[0m[[31merror[0m] [0munrecoverable error[0m
[0m[[31merror[0m] [0mTotal time: 46 s, completed May 14, 2012 5:38:17 PM[0m


scala.reflect.internal.Types$TypeError: reassignment to val
	at scala.tools.nsc.typechecker.Contexts$Context.issue(Contexts.scala:363)
	at scala.tools.nsc.typechecker.ContextErrors$ErrorUtils$.issueTypeError(ContextErrors.scala:78)
	at scala.tools.nsc.typechecker.ContextErrors$ErrorUtils$.issueNormalTypeError(ContextErrors.scala:63)
	at scala.tools.nsc.typechecker.ContextErrors$TyperContextErrors$TyperErrorGen$.AssignmentError(ContextErrors.scala:269)
	at scala.tools.nsc.typechecker.Typers$Typer.fail$3(Typers.scala:3916)
	at scala.tools.nsc.typechecker.Typers$Typer.typedAssign$1(Typers.scala:3940)
	at scala.tools.nsc.typechecker.Typers$Typer.unvirtualize$1(Typers.scala:4624)
	at scala.tools.nsc.typechecker.Typers$Typer.typedApply1$1(Typers.scala:4532)
	at scala.tools.nsc.typechecker.Typers$Typer.typedApply$1(Typers.scala:4407)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5355)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:2562)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.collection.immutable.List.loop$1(List.scala:163)
	at scala.collection.immutable.List.mapConserve(List.scala:179)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2657)
	at scala.tools.nsc.typechecker.Typers$Typer.typedBlock(Typers.scala:2148)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$typed1$3.apply(Typers.scala:5205)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5204)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.transformedOrTyped(Typers.scala:5918)
	at scala.tools.nsc.typechecker.Typers$Typer.typedDefDef(Typers.scala:1979)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5173)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:2562)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.collection.immutable.List.loop$1(List.scala:163)
	at scala.collection.immutable.List.mapConserve(List.scala:179)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2657)
	at scala.tools.nsc.typechecker.Typers$Typer.typedTemplate(Typers.scala:1723)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$49.apply(Typers.scala:1588)
	at scala.tools.nsc.typechecker.Typers$Typer.typedClassDef(Typers.scala:1587)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5164)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:2562)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.collection.immutable.List.loop$1(List.scala:163)
	at scala.collection.immutable.List.mapConserve(List.scala:179)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2657)
	at scala.tools.nsc.typechecker.Typers$Typer.typedBlock(Typers.scala:2148)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$typed1$3.apply(Typers.scala:5205)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5204)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$72.apply(Typers.scala:2672)
	at scala.tools.nsc.typechecker.Typers$Typer.typedArg(Typers.scala:2672)
	at scala.tools.nsc.typechecker.Typers$Typer.loop$1(Typers.scala:2691)
	at scala.tools.nsc.typechecker.Typers$Typer.typedArgs(Typers.scala:2697)
	at scala.tools.nsc.typechecker.Typers$Typer.doTypedApply(Typers.scala:2938)
	at scala.tools.nsc.typechecker.Typers$Typer.typedApply1$1(Typers.scala:4550)
	at scala.tools.nsc.typechecker.Typers$Typer.typedApply$1(Typers.scala:4407)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5355)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:2562)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.collection.immutable.List.loop$1(List.scala:163)
	at scala.collection.immutable.List.mapConserve(List.scala:179)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2657)
	at scala.tools.nsc.typechecker.Typers$Typer.typedBlock(Typers.scala:2148)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$typed1$3.apply(Typers.scala:5205)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5204)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$72.apply(Typers.scala:2672)
	at scala.tools.nsc.typechecker.Typers$Typer.typedArg(Typers.scala:2672)
	at scala.tools.nsc.typechecker.Typers$Typer.loop$1(Typers.scala:2691)
	at scala.tools.nsc.typechecker.Typers$Typer.typedArgs(Typers.scala:2697)
	at scala.tools.nsc.typechecker.Typers$Typer.doTypedApply(Typers.scala:2938)
	at scala.tools.nsc.typechecker.Typers$Typer.typedApply1$1(Typers.scala:4550)
	at scala.tools.nsc.typechecker.Typers$Typer.typedApply$1(Typers.scala:4407)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5355)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5602)
	at scala.tools.nsc.typechecker.Typers$Typer.typedIf$1(Typers.scala:3949)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5244)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typedBlock(Typers.scala:2149)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$typed1$3.apply(Typers.scala:5205)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5204)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5602)
	at scala.tools.nsc.typechecker.Typers$Typer.typedIf$1(Typers.scala:3949)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5244)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5602)
	at scala.tools.nsc.typechecker.Typers$Typer.typedLabelDef(Typers.scala:2064)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5179)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:2562)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.collection.immutable.List.loop$1(List.scala:163)
	at scala.collection.immutable.List.mapConserve(List.scala:179)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2657)
	at scala.tools.nsc.typechecker.Typers$Typer.typedBlock(Typers.scala:2148)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$typed1$3.apply(Typers.scala:5205)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5204)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.transformedOrTyped(Typers.scala:5918)
	at scala.tools.nsc.typechecker.Typers$Typer.typedDefDef(Typers.scala:1979)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5173)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:2562)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.collection.immutable.List.loop$1(List.scala:163)
	at scala.collection.immutable.List.mapConserve(List.scala:179)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2657)
	at scala.tools.nsc.typechecker.Typers$Typer.typedTemplate(Typers.scala:1723)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$49.apply(Typers.scala:1588)
	at scala.tools.nsc.typechecker.Typers$Typer.typedClassDef(Typers.scala:1587)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5164)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:2562)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.collection.immutable.List.loop$1(List.scala:163)
	at scala.collection.immutable.List.mapConserve(List.scala:179)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2657)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5160)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStat$1(Typers.scala:2562)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70$$anonfun$71.apply(Typers.scala:2658)
	at scala.collection.immutable.List.loop$1(List.scala:163)
	at scala.collection.immutable.List.mapConserve(List.scala:179)
	at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$70.apply(Typers.scala:2658)
	at scala.tools.nsc.typechecker.Typers$Typer.typedStats(Typers.scala:2657)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5160)
	at scala.tools.nsc.transform.Erasure$Eraser.typed1(Erasure.scala:751)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5528)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5586)
	at scala.tools.nsc.transform.Erasure$ErasureTransformer$$anonfun$transform$2.apply(Erasure.scala:1146)
	at scala.tools.nsc.transform.Erasure$ErasureTransformer.transform(Erasure.scala:1142)
	at scala.tools.nsc.ast.Trees$Transformer.transformUnit(Trees.scala:228)
	at scala.tools.nsc.transform.Transform$Phase.apply(Transform.scala:30)
	at scala.tools.nsc.Global$GlobalPhase.applyPhase(Global.scala:432)
	at scala.tools.nsc.Global$GlobalPhase$$anonfun$run$1.apply(Global.scala:398)
	at scala.tools.nsc.Global$GlobalPhase$$anonfun$run$1.apply(Global.scala:392)
	at scala.collection.Iterator$class.foreach(Iterator.scala:697)
	at scala.collection.AbstractIterator.foreach(Iterator.scala:1124)
	at scala.tools.nsc.Global$GlobalPhase.run(Global.scala:392)
	at scala.tools.nsc.Global$Run.compileUnitsInternal(Global.scala:1336)
	at scala.tools.nsc.Global$Run.compileUnits(Global.scala:1309)
	at scala.tools.nsc.Global$Run.compileSources(Global.scala:1303)
	at scala.tools.nsc.Global$Run.compile(Global.scala:1436)
	at xsbt.CompilerInterface.run(CompilerInterface.scala:92)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at sbt.compiler.AnalyzingCompiler.call(AnalyzingCompiler.scala:57)
	at sbt.compiler.AnalyzingCompiler.compile(AnalyzingCompiler.scala:29)
	at sbt.compiler.AnalyzingCompiler.compile(AnalyzingCompiler.scala:25)
	at sbt.AggressiveCompile$$anonfun$5.compileScala$1(AggressiveCompile.scala:67)
	at sbt.AggressiveCompile$$anonfun$5.apply(AggressiveCompile.scala:79)
	at sbt.AggressiveCompile$$anonfun$5.apply(AggressiveCompile.scala:57)
	at sbt.inc.IncrementalCompile$$anonfun$doCompile$1.apply(Compile.scala:23)
	at sbt.inc.IncrementalCompile$$anonfun$doCompile$1.apply(Compile.scala:21)
	at sbt.inc.Incremental$.cycle(Incremental.scala:33)
	at sbt.inc.Incremental$.compile(Incremental.scala:20)
	at sbt.inc.IncrementalCompile$.apply(Compile.scala:19)
	at sbt.AggressiveCompile.compile2(AggressiveCompile.scala:87)
	at sbt.AggressiveCompile.compile1(AggressiveCompile.scala:41)
	at sbt.AggressiveCompile.apply(AggressiveCompile.scala:28)
	at sbt.Compiler$.apply(Compiler.scala:98)
	at sbt.Defaults$$anonfun$compileTask$1.apply(Defaults.scala:571)
	at sbt.Defaults$$anonfun$compileTask$1.apply(Defaults.scala:571)
	at sbt.Scoped$$anonfun$hf2$1.apply(Structure.scala:578)
	at sbt.Scoped$$anonfun$hf2$1.apply(Structure.scala:578)
	at scala.Function1$$anonfun$compose$1.apply(Function1.scala:49)
	at sbt.Scoped$Reduced$$anonfun$combine$1$$anonfun$apply$12.apply(Structure.scala:311)
	at sbt.Scoped$Reduced$$anonfun$combine$1$$anonfun$apply$12.apply(Structure.scala:311)
	at sbt.$tilde$greater$$anonfun$$u2219$1.apply(TypeFunctions.scala:40)
	at sbt.std.Transform$$anon$5.work(System.scala:67)
	at sbt.Execute$$anonfun$submit$1$$anonfun$apply$1.apply(Execute.scala:221)
	at sbt.Execute$$anonfun$submit$1$$anonfun$apply$1.apply(Execute.scala:221)
	at sbt.ErrorHandling$.wideConvert(ErrorHandling.scala:18)
	at sbt.Execute.work(Execute.scala:227)
	at sbt.Execute$$anonfun$submit$1.apply(Execute.scala:221)
	at sbt.Execute$$anonfun$submit$1.apply(Execute.scala:221)
	at sbt.ConcurrentRestrictions$$anon$4$$anonfun$1.apply(ConcurrentRestrictions.scala:159)
	at sbt.CompletionService$$anon$2.call(CompletionService.scala:30)
	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)
	at java.util.concurrent.FutureTask.run(FutureTask.java:166)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)
	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)
	at java.util.concurrent.FutureTask.run(FutureTask.java:166)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
	at java.lang.Thread.run(Thread.java:722)

